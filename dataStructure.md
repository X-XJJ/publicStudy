# 基本概念
- 数据结构三要素：运算，物理结构，逻辑结构
- 数据：
- 结构：
-
- 存储结构（物理结构）：顺序、链式、索引、散列
- 逻辑结构：
  - 线性：线性表、栈、队列
  - 非线性：树、图、集合
- 对数据进行各种非数值运算：查找、排序、插入、删除、修改、遍历
## 算法
- 算法：
- 特性：
-
- 不同算法 = 不同运行时间&存储空间效率 = 不同逻辑结构 + 不同存储结构 + 不同运算方法
-
- 时间复杂度O(n)
> O(1) < O(log(2)(n)) < O(n) < O(nlog(2)(n)) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
-
- 空间复杂度S(n)

# 线性表
- 基本操作
- 表示：顺序、链式
- 顺序表vs链表
- 数组：连续存储空间
## 顺序存储
- 顺序表
- - 无序O(n)，有序折半O(log(2)(n))，序号O(1)
- 数据存储在一组连续的地址中，增删慢，无法扩容
-
## 链式存储
- 链表
- - 单链表O(n)，双链表O(n)，循环链表——指针
- - 静态链表——数组
- 链式表示，逻辑相连，地址随机
-

# 队列 栈
- 栈
  - 顺序栈：int top，括号匹配
  - 链栈：head→，表达式求值，前中后缀表达式
  - 共享栈：两个栈共享一个一维数据空间，栈底分别在空间的两端，递归
- 队列
  - 顺序队列，主机&外设的速度不匹配
  - 循环队列，多用户引起的资源竞争
  - 链式队列
  - 双端队列，
- 矩阵的压缩存储：对称矩阵，稀疏矩阵
- 层次遍历，计算机系统
## 特殊矩阵的压缩存储
- 矩阵的压缩存储
- 稀疏矩阵
-

# 树 二叉树
- n个结点，n-1条边
- 度 = m，结点的子结点个数，第i层结点数 = m^(i-1)
- 路径长度：
- 高 = h 的m叉树，结点最多 = 1 + m + m^2 + ... + m^(i-1) = (1-m^h)/(1-m)
-
## 二叉树
- 顺序存储，链式存储（n个点-n+1个空链域）
- 遍历，X序+中序，确定一个二叉树
  - 先序-根左右，中序-左根右，后序-左右根，层次-借助队列
- 满二叉树，结点(2^n)-1，
- 完全二叉树
- 线索二叉树
- 二叉排序树，左小右大，平均查找长度取决于h，单支 ~ 平衡 = O(n) ~ O(log(2)n)
- 平衡二叉树，Δh ≤1，旋转-插入调整最小不平衡子树，平均查找长度O(log(2)n)
-
## 树 森林
- 树
  - 双亲表示，孩子表示，孩子兄弟表示
  - 先根，后根（中序）
- 森林：先序，中序
- 哈弗曼树，哈弗曼编码，Huffman
  - 最优带权路径长度 = ∑权值 x 路经min长
  - n个结点造huffman，共出2n-1个点，新建n-1个点
- 并查集

# 图
- 无向图
  - 连通分量 = 极大连通子图，含all边，v - w
  - 非连边＜n-1，否则有环
- 有向图
  - 强连通分量 = 极大强连通图，含all边，v(尾) →w(头) →v
- 距离：最短路径长度
## 存储操作
- 邻接矩阵
  - 稠密的n ×n矩阵，顺序存储，空O(n^2)
  - A[i][j] = 1 or 权值，点i到点j有边；0 or ∞，无边
- 邻接表
  - 稀疏的，链接存储，空无向O(n+2e)，空有向O(n+e)
  - 顶点H[1] →顶点1连的边1 →边2...
  - 顶点H[2] →顶点2连的边1...
- 十字链表
- 邻接多重表
## 遍历
- 广度优先 BFS Breadth-First-Search
  - 层序，辅助：visit[i]，队列Q
  - 单源最短路径：按距离由近到远遍历
  - 由已知顶点触发，依次访问已知点的未访问过的邻接点
  - 空O(n)时，邻接表矩阵O(n^2)，邻接表O(n+e)
- 深度优先 DFS Depth-First-Search
  - 先序，判断回路，一次访问完all点
  - 从已知顶点出发，访问任一未访邻点，接着访问该未访邻点的任一未访邻点，...，直到无退回，再访
  - 空O(n)时，邻接表矩阵O(n^2)，邻接表O(n+e)
- 连通性
## 应用
- 最小生成树 MST Minimum-Spanning-Tree
  - 含all点，权值和min，边数 = n - 1
  - 贪心策略
    - 普利姆算法Prim，稠密，时O(n^2)，选已有点出发，并min边和连着的点
    - 克鲁斯卡尔Kruskal，稀疏，时O(e ×loge)，选任意点出发，并min边且不构成回路
- 最短路径
  - 点to点，路径权值min
  - 单源最短Dijkstra迪杰斯特拉，时O(n^2)，源to各点，已有路径中招min的，并其“终点”
  - 各对顶点最短Floyd弗洛伊德，时O(n^3)，方阵更替，A(-1) A(0) A(1) ... A(n-1)
  - A[i][j] = 边 or 路径权值，A(-1)初始化，A(k)[i][j] = min{ A(k-1)[i][j], A(k-1)[i][j] + A(k-1)[k][j] }
- 拓扑排序
  - AOV网，有向无环图，all点序列 = 活动序列
  - 矩阵O(n^2+e)，表(n+e)，输出后删除无前趋的点和点的边们
- 关键路径
  - AOE网，有向带权图，起 →终边权值max = 关键活动
  - 事件Vi to 事件Vj，中间经过 活动k
  - 事件最迟 = min{下事件最迟 - 活动持续}，活动最早 = 活动最迟 即为关键活动
  - 事件最早 = max{上事件最早 + 活动持续}

# 查找
- 顺序 树 散列 字符串模式匹配
## 顺序
- 顺序查找
- 二分/折半 查找
- 分块查找

## 树查找
- B树
- B+树
- 红黑树

## 散列表（Hash表）
- 散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值
- 散列函数Hash(key)：Addr = Hash(key) = H(key)
  - 把查找表中的关键字映射为该关键字对应的存放地址Addr
  - Addr =｛数组下标、索引、内存地址……｝
- 冲突：Hash(key1) = Hash(key2)=... 两个或以上关键字映射到同一地址
- 同义词：key1 key2 发生碰撞的不同关键字，为一组同义词
- 散列表：一种数据结构，根据关键字直接进行访问
- 查找性能理想情况O(1)
- 适用情况：数据量多，需要快速查找定位
### 散列函数构造方法
- 直接定址法：H(key) = a ×key + b
  - 关键字的线性函数，适合分布基本连续的关键字，无冲突，易空间浪费
- 除留余数法：H(key) = key % p = key mod p
  - 关键字个数 = m，p一般选择≤m的最大质数
- 数字分析法：H(key) = 数码分部均匀的若干位？？？
  - 适合已知的关键字合集
- 平方取中法：H(key) = key^2的中间几位
  - 具体几位看情况，适合关键字每一位都不够均匀or均小于散列地址所需位数
- 折叠法：H(key) = 关键字分割成的位数相同的几部分的叠加和
  - 适合关键字位数多，每一位上数字分布均匀
### 解决冲突方法
#### 开放定址法
- 公式：Hi = ( H(key) + di ) % m
  - 允许同义词标中的地址和正常计算的非同义词地址发生冲突
  - 可存放新表项的空闲地址向同义词+非同义词开放
  - Hi = 发生冲突后第i次探测的Addr，di=增量序列
  - m=关键字个数，i=1,2,...,k(k≤m-1)
- 线性探测法：di = 1，2，…，m-1
  - 从冲突地址开始顺序查表中的下一个单元，当查到m-1时，下一个是表首地址0
- 平方探测法/二次探测：di = 1^2，-1^2，2^2，-2^2，…，k^2，-k^2
  - k≤m/2，m为质数且m可表示为4k+3。此m是表长否？？？k是di里的k否？？？
  - 避免“堆积”问题，不能探测散列表所有单元，至少可以探测一半
- 再散列法/双散列法：di = Hash2(key)
  - H(key)的地址冲突时，再用H2(key)算关键字地址增量
  - 最多m-1次可遍历表中所有位置，回到H0位置
- 伪随机序列法：di = 伪随机数序列
- 建立公共溢出区？？？
- 堆积问题：同义词冲突的探查序列，和非同义词之间不同的探查序列，交织，→关键字查询需要较长的探测距离，降低散列的效率。？？
- 不可随便物理删除表中的已有元素，会截断其他冲突元素的查找地址
#### 拉链法/链地址法
- 一组同义词存储于一个线性链表，这组同义词的散列地址对该链表进行唯一标识
- 避免同义词和非同义词冲突，适合经常插入、删除的情况，操作主要在同义词链中进行
  - eg：假设Addr=i的同义词链表头指针，存在散列表的第i个单元中。关键字序列key={10,23,32,55}，散列函H(key)=key%3，(表长=4)
  - 则通过H(key)分别得到散列地址1，2，2，1，假设Addr=数组下标，散列表为HH[4]，则HH[1]中存储同义词10、55的链表头指针，链表第一个元素为10，第二个为55
    HH[0]^
    HH[1]→10→55
    HH[2]→23→32
    HH[3]^

## 字符串模式匹配
- 简单
- 改进 KMP

# 排序

## 插入
- 直接
- 折半
- 希尔
## 交换
- 冒泡
- 快速
## 选择
- 简单选择
- 堆
## 归并、基数
- 归并
- 基数

## 以上为内部排序
- 比较
- 应用

## 外部排序
- 多路平衡归并
- 败者树
- 置换-选择
- 最佳归并树
## 其他
- 睡眠排序
  - 根据CPU的调度算法实现——讲cup调度算法？？
  - 对一组数据进行排序，不能存在负数值，这个数是多大，那么就在线程里睡眠它的10倍再加10
  - 睡眠和它的数值不一样大的原因：当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果
  - 利用栈，醒一个入栈一个，出栈可得倒序结果

# 其他
## 筛子算法 Erat osthenes
最早计算素数个数的算法



