# 基本概念
- 数据结构：相互之间存在一种or多种特定关系的数据元素的集合
- 三要素：逻辑结构，物理结构，数据的运算
- 存储结构/物理结构：顺序、链式、索引、散列
- 逻辑结构：
  - 线性：线性表、栈、队列
  - 非线性：树、图、集合
- 对数据进行各种非数值运算：查找、排序、插入、删除、修改、遍历
- 算法：指令的有穷序列，有穷、确定、可行、输入、输出
- 算法评价 = 不同运行时间 & 存储空间效率 = 不同逻辑结构 + 不同存储结构 + 不同运算方法
  - 时间复杂度O(n)
  > O(1) < O(log(2)(n)) < O(n) < O(nlog(2)(n)) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
  - 空间复杂度O(n)，原地工作即O(1)
  - 排序算法稳定性

# 线性表
- 数据表由数据元素组成，数据元素由一个整数or一个实数or一个字符or一个字符串or若干个数据项组成
	- 数据元素 = 结点 = 记录，数据项 = 字段 = 域，键 = 关键字 = 能唯一标识结点的字段
- 存储结构：顺序、链式
- 顺序存储 顺序表
  - 无序O(n)，有序折半O(log(2)(n))，序号O(1)——数组
  - 逻辑相连，地址相连，数据存储在一组连续的地址中
  - 可随机存取，存储空间较固定，增删慢，无法扩容
  - 插入、删除、连带许多元素的移动
- 链式存储 链表
  - 单链表O(n)，双链表O(n)，循环链表——指针
  - 静态链表——数组下标 replace 指针
  - 逻辑相连，地址随机，链表节点为结构体定义
  - 只顺序存取，存储空间不固定，带头结点and不带头结点
  - 插入、删除、合并，头插法（实现逆序）、尾插法

# 队列 栈
- 存储结构：顺序、链式
- 本质：限定了一定操作的线性表
- 栈
  - 顺序栈：int top，顺序存储——括号匹配
  - 链栈：head→，链式存储——表达式求值，前中后缀表达式
  - 共享栈/双向栈：两个栈共享一个一维数据空间，栈底分别在空间的两端，递归
  - 应用：实现逆序，递归算法的非递归实现，数据输入输出的顺序分析，算术运算表达式-前中后缀，括号匹配，树的深度遍历
- 队列
  - 头尾指针配置，队满队空判断
  - 顺序队列，主机&外设的速度不匹配
  - 循环队列，取余表示，多用户引起的资源竞争
  - 链式队列
  - 双端队列，两端限制操作
  - 应用：树的层次遍历，缓冲区队列-解决计算机速度不匹配问题
- 矩阵
  - 特殊矩阵：稀疏矩阵，上下三角矩阵，n对角矩阵，堆成矩阵
  - 存储：按行or按列优先
  - 特殊矩阵的压缩存储：对称矩阵，稀疏矩阵
- 广义表
  - 深度-括号最大层数，长度-最上层元素个数，GetHead() GetTail()

# 树 二叉树
- 存储结构：顺序、链式
- n个结点，n-1条边
- 结点的？度 = m = 结点的子结点个数，第i层结点数 = m^(i-1)
- 高 = h 的m叉树，结点最多 = 1 + m + m^2 + ... + m^(i-1) = (1-m^h)/(1-m)
- 路径长度：
## 二叉树
- 顺序存储，链式存储（n个点-n+1个空链域）
- 遍历，X序+中序，确定一个二叉树
  - 深度遍历：先序-根左右，中序-左根右，后序-左右根
  - 层次遍历：借助队列
- 满二叉树，结点 = (2^n)-1，
- 完全二叉树
- 线索二叉树，利用空指针
- 二叉排序树
  - 插入算出，左小右大
  - 平均查找长度取决于h，单支 ~ 平衡 = O(n) ~ O(log(2)n)
- 平衡二叉树
  - 本质是二叉排序树，Δh ≤1
  - 旋转：插入or删除后调整最小不平衡子树，LL-右单，RR-左单，RL-先右后左，LR-先左后右
  - 平均查找长度O(log(2)n)
- 最优二叉树/哈弗曼树 Huffman
  - 生成：
  - 哈弗曼编码：前缀编码，不等长编码-节省空间
  - 最优带权路径长度 WPL = ∑权值 x 路经min长
  - n个结点造huffman，共出2n-1个点，新建n-1个点
  - k叉树按规则补空白节点
- 并查集
- 算术表达式的生成、求解
- 二叉树的估计
## 树 森林
- 与二叉树之间的转化：左子树对应兄弟，右子树对应子女
- 树
  - 双亲表示，孩子表示，孩子兄弟表示
  - 先根，后根（中序）
- 森林：先序，中序

# 图
- 距离：最短路径长度
- 无向图
  - 度
  - 连通分量 = 极大连通子图，含all边，v - w
  - 非连边＜n-1，否则有环
- 有向图
  - 入度、出度
  - 强连通分量 = 极大强连通图，含all边，v(尾) →w(头) →v
- 连通图：极大连通子图-连通分量，极小连通子图-边数最少
- 强连通图-强连通分量
- 简单图：边不重复，不存在自身到自身边
- 多重图：
- 完全图：任意两个顶点之间都存在边/方向相反两条弧
- 子图：边与顶点对应，不是任何原图成员都能构成
## 物理存储
- 邻接矩阵
  - 表示唯一，稠密的n*n矩阵，顺序存储，空O(n^2)
  - A[i][j] = 1 or 权值，点i到点j有边；0 or ∞，无边
- 邻接表
  - 表示可能不同，稀疏的，链接存储，空无向O(n+2e)，空有向O(n+e)，如：
  - 顶点H[1] →顶点1连的边1 →顶点1连的边2...
  - 顶点H[2] →顶点2连的边1...
  - 顶点H[3] →...
- 十字链表：有向图
- 邻接多重表：无向图
## 遍历
- 广度优先 BFS Breadth-First-Search
  - 层序，辅助：visit[i]，队列Q
  - 单源最短路径：按距离由近到远遍历
  - 由已知顶点触发，依次访问已知点的未访问过的邻接点
  - 空O(n)时，邻接表矩阵O(n^2)，邻接表O(n+e)
- 深度优先 DFS Depth-First-Search
  - 先序，判断回路，一次访问完all点
  - 从已知顶点出发，访问任一未访邻点，接着访问该未访邻点的任一未访邻点，...，直到无退回，再访
  - 空O(n)时，邻接表矩阵O(n^2)，邻接表O(n+e)
- 连通性
## 应用
- 最小生成树 MST Minimum-Spanning-Tree span-范围
  - 含all点，权值和min，边数 = n - 1
  - 贪心策略/算法
    - 普利姆算法Prim，稠密，用顶点分析，时O(n^2)，选已有点出发，并min边和连着的点
    - 克鲁斯卡尔Kruskal，稀疏，用边分析，时O(e*loge)，选任意点出发，并min边且不构成回路
- 最短路径
  - 点to点，路径权值min
  - 单源到各顶点最短：Dijkstra迪杰斯特拉，时O(n^2)，源to各点，已有路径中招min的，并其“终点”
  - 任意两两顶点最短：Floyd弗洛伊德，迭代插点，时O(n^3)，方阵更替，A(-1) A(0) A(1) ... A(n-1)
  - A[i][j] = 边 or 路径权值，A(-1)初始化，A(k)[i][j] = min{ A(k-1)[i][j], A(k-1)[i][j] + A(k-1)[k][j] }
- 拓扑排序
  - AOV网 Activity-On-Vertex-Network：顶点代表活动，vertex-顶点
  - 有向无环图DAG Directed-Acyclic-Graph：all点序列 = 活动序列
  - 矩阵O(n^2+e)，表(n+e)，输出后删除无前趋的点和点的边们
- 关键路径
  - AOE网 Activity-On-Edge-Network：边代表活动，edge-边
  - 有向带权图，起 →终边权值max = 关键活动
  - 顶点 = 事件，边 = 活动：事件Vi to 事件Vj，中间经过 活动k
  - 事件最迟 = min{下事件最迟 - 活动持续}
  - 事件最早 = max{上事件最早 + 活动持续}
  - 活动最早 = ？
  - 活动最迟 = ？
  - 关键活动条件：活动最早 = 活动最迟
  - 桥：
  - 关键路径上提高效率，才可能提升整体效率

# 查找
- 静态适合：顺序，折半，散列
- 动态适合：二叉排序树，散列，二叉平衡，B树
- 平均查找长度 ASL Average-Search-Length
  - 设 n = 表长，Pi = 找第i个元素的概率-默认均值1/n，Ci = 找到第i个元素进行的比较次数
  - ASL = ∑Pi ·Ci = 关键字比较次数的平均值
## 线性结构
- 顺序
  - 线性表：ASL成功 = (n+1)/2，ASL失败 = n + 1
  - 有序表：ASL成功 = (n+1)/2，ASL失败 = n/2 + n/(n+1)
- 折半/二分
  - 只用于有序顺序表，过程-判定树（平衡二叉树），时O(log(2)n)
  - ASL成功 = (n+1)/n ·log(2)(n+1) ≈log(2)(n+1) - 1
- 分块（索引顺序）：ASL成功 = ASL索引 + ASL块内，块内顺序查找
## 树查找
- 二叉排序
- 二叉平衡
- B树
  - 多路平衡查找树，平衡因子 = 0
  - m阶，all结点中孩子结点数的最大值，min = (m/2)的向上取整
  - 限定条件：根结点和非叶结点的关键字个数，子树个数的限定范围
  - 插入-分裂，删除-从左右兄弟借-不够借则递归向上合并
  - 常用：文件在内存、磁盘的分层查找
- B+树：非叶节点 = 索引作用，常用于数据库，限定条件，与B树的区别
- 红黑树
## 散列表（Hash表）
- 散列、杂凑，或音译为哈希：把任意长度的输入通过散列算法变换成固定长度的输出
- 适用情况：直接映射，效率高；数据量多，需要快速查找定位
- 散列函数Hash(key)：Addr = Hash(key) = H(key)
  - 把查找表中的关键字映射为该关键字对应的存放地址Addr
  - Addr =｛数组下标、索引、内存地址……｝
- 冲突：Hash(key1) = Hash(key2)=... 两个或以上关键字映射到同一地址
- 同义词：key1 key2 发生碰撞的不同关键字，为一组同义词
- 散列表：一种数据结构，根据关键字直接进行访问
- 查找性能理想情况O(1)，查找效率 = 装填因子 + 散列函数 + 处理冲突方法
- ASL 取决于装填因子α，α= 表中记录数/散列表长
### 散列函数构造
- 直接定址法：H(key) = a*key + b，常用
  - 关键字的线性函数，适合分布基本连续的关键字，无冲突，易空间浪费
- 除留余数法：H(key) = key % p = key mod p，常用
  - 关键字个数 = m，p一般选择≤m的最大质数
- 数字分析法：H(key) = 数码分部均匀的若干位？？？
  - 适合已知的关键字合集
- 平方取中法：H(key) = key^2的中间几位
  - 具体几位看情况，适合关键字每一位都不够均匀or均小于散列地址所需位数
- 折叠法：H(key) = 关键字分割成的位数相同的几部分的叠加和
  - 适合关键字位数多，每一位上数字分布均匀
### 解决冲突
#### 开放定址法
- 公式：Hi = ( H(key) + di ) % m
  - 允许同义词标中的地址和正常计算的非同义词地址发生冲突
  - 可存放新表项的空闲地址向同义词+非同义词开放
  - Hi = 发生冲突后第i次探测的Addr，di = Δ增量序列
  - m = 关键字个数，i = 1,2,...,k(k≤m-1)
- 线性探测：di = 1，2，…，m-1
  - 从冲突地址开始顺序查表中的下一个单元，当查到m-1时，下一个是表首地址0
- 平方探测/二次探测：di = 1^2，-1^2，2^2，-2^2，…，k^2，-k^2
  - k≤m/2，m为质数且m可表示为4k+3。此m是表长否？？？k是di里的k否？？？
  - 避免“堆积”问题，不能探测散列表所有单元，至少可以探测一半
- 再散列/双散列法：di = Hash2(key)
  - H(key)的地址冲突时，再用H2(key)算关键字地址增量
  - 最多 m-1 次可遍历表中所有位置，回到H0位置
- 伪随机序列法：di = 伪随机数序列
- 建立公共溢出区？？？
- 堆积问题：同义词冲突的探查序列，和非同义词之间不同的探查序列，交织，→关键字查询需要较长的探测距离，降低散列的效率。？？
- 不可随便物理删除表中的已有元素，会截断其他冲突元素的查找地址
#### 拉链法/链地址法
- 一组同义词存储于一个线性链表，这组同义词的散列地址对该链表进行唯一标识
- 避免同义词和非同义词冲突，适合经常插入、删除的情况，操作主要在同义词链中进行
  - eg：假设Addr=i的同义词链表头指针，存在散列表的第i个单元中。关键字序列key={10,23,32,55}，散列函H(key)=key%3，(表长=4)
  - 则通过H(key)分别得到散列地址1，2，2，1，假设Addr=数组下标，散列表为HH[4]，则HH[1]中存储同义词10、55的链表头指针，链表第一个元素为10，第二个为55
    HH[0]^
    HH[1]→10→55
    HH[2]→23→32
    HH[3]^
## 分析字符串模式匹配 KMP Knuth-Morris-Pratt Algorithm
- 主串指针不回溯，next数组，模式串的指针依据next数组滑动，避免无意义比较
- 改进 KMP，nextval数组

# 排序
- 稳定性：设数列中存在a[i]=a[j]，排序之后a[i]和a[j]的相对位置不变，则算法稳定
- 外部排序：多路归并
- 内部排序：如下
## 插入
- 直接：顺序比较，插入调序，表L：有序L[l-(i-1)] ~ Li ~ 无序剩余L
- 折半：折半查找，其余同上
- 希尔：分割若干子表L[i, i+d, i+2d, ...]，子表内使用直接排序
## 交换
- 冒泡：一趟内两两比较相邻元素，最多n-1趟
- 快排：平均性能最优
  - 来回扫，动一个数换一次扫的方向
  - 小于枢值放左边，大于的从右开始放（即交换元素）
## 选择（不稳）
- 简单选择：表L：有序L[] ~ Li ~ 无序剩余L，在无序中找min的与该位置Li交换
- 堆排序  ：树形选择，小根堆-顶最小，大根堆-顶最大-孩子≤双亲
## 归并、基数
- 归并：二路归并，两两归并
- 基数：多关键字，按关键字的每个数位排序，如先比个位，再比十位，最后百位
## 以上为内部排序
算法     |稳定性|时O()          |空O(1)      |备注
---------|------|---------------|------------|----
--插入---|------|---------------|------------
直接插入 |√    |O(n^2)         |√          |默认稳定、空间O(1)
折半插入 |√    |O(n^2)         |√
希尔排序 |不稳  |O(1.3)？？     |√
--交换---|------|---------------|------------
冒泡排序 |√    |O(n^2)         |√          |一趟一个最终位置
快速排序 |不稳  |O(n ·log(2)n) |O(log(2)n)栈|一趟一个最终位置
--选择---|------|---------------|------------
简单选择 |不稳  |O(n^2)         |√          |一趟一个最终位置
堆排序   |不稳  |O(n ·log(2)n) |√          |一趟一个最终位置
---------|------|---------------|------------
二路归并 |√    |O(n ·log(2)n) |O(n)
---------|------|---------------|------------
基数排序 |√    |O(d(n+r))？？  |O(r)        |不需元素间比较

## 外部排序
- 核心耗时：I/O存取
- 核心问题：内存空间有限
- 多路平衡归并
  - 一整套解决方案
  - m路归并：减少IO费时
  - 败者树：抵消m增多对比较次数的影响
  - 置换-选择：增大归并段长，生成不同长度段以减小趟数
  - 最佳归并树：减少IO访问次数，最短WPL
## 其他
- 睡眠排序
  - 根据CPU的调度算法实现——讲cup调度算法？？
  - 对一组数据进行排序，不能存在负数值，这个数是多大，那么就在线程里睡眠它的10倍再加10
  - 睡眠和它的数值不一样大的原因：当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果
  - 利用栈，醒一个入栈一个，出栈可得倒序结果

# 串


# 其他
## 筛子算法 Erat osthenes
最早计算素数个数的算法

# Code
## 线性表
- 插入x到表长pn的线性表的i位置
int sq_insert(int list[], int *pn, int i, int x)
{
		if(i < 0 || i > *pn) return 1;	//i不在可插范围
		if(*pn == MAXSIZE) return 2;		//表满
		for(int j = *pn; j > i; j--)	//倒着挪
				list[j] = list[j-1];
		list[j] = x;
		++(*pn);
		return 0;
}

## 查找
- 二分查找
~~~
int binarySearch(int key, int list[], int n)
{//key-查找项 n-表长
    int low, high, mid;
    low = 0;
    high = n - 1;
    while(low <= high)
    {
        mid = (low + high)/2;
        if(x < list[mid])
            high = mid - 1;
        else if(x > list[mid])
            low = mid + 1;
        else //找到查找项
            return mid;
    }
    return -1;
}
~~~

## 排序
- 直接插入排序
~~~
int insertSort(int v[], int n)
{//n-表长
		int temp;
		int i;
		for(i = 1; i < n; i++)		//i=1 第一个元素已是一个有序子表
		{
				if(v[i] < v[i - 1])		//若v[i]<有序子表的末尾最大值 则需要找位置 v[i] 直接插入有序子表
				{
						temp = v[i];
						for(int j = i-1; temp < v[j]; j--)
						{
								v[j+1] = v[j];		//有序子表向后挪位
						}
						v[j+1] = temp;		//找到 temp > v[j] 的位置 插入 temp 到 v[j] 后 
				}
		}
}

~~~

- 交换排序
~~~
~~~

- 希尔排序
~~~
int shellSort(int v[], int n)
{
		int i,temp;
		int dk;  //dk-元素间隔
		
		//控制步长间隔递减
		for(dk = n/2; dk > 0 ;dk /= 2）
		{
				//划分希尔子表 [i-dk,i,i+dk,i+2dk,...] 即[j,j+dk,j+2dk,...]
				for(i = dk; i < n; i++)
				{
						//1 子表排序使用 直接插入排序
						if(v[i] < v[i - dk]
						{
								temp = v[i];
								for(int j = i - dk; temp < v[j]; j -= dk)
								{
										v[j+dk] = v[j];
								}
								v[j+dk] = temp;
						}
						
						//2 子表排序使用 有序子表的交换排序???
						for(int j = i-dk; (j >= 0) && (v[j] > v[j+dk]); j -= dk)
						{
								temp = v[j];
								v[j] = v[j+dk];
								v[j+dk] = temp;
						}
				}
		}
}
~~~

