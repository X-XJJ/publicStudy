结合图像理解！！脑子里要有动态图过程图！！

# 一、基本概念
- 数据结构：相互之间存在一种or多种特定关系的数据元素的集合
- 三要素：逻辑结构，物理结构，数据的运算
- 存储结构/物理结构：顺序、链式、索引、散列（哈希）
- 逻辑结构：
  - 线性：线性表、栈、队列
  - 非线性：树、图、集合
- 对数据进行各种非数值运算：查找、排序、插入、删除、修改、遍历
- 算法：指令的有穷序列，有穷、确定、可行、输入、输出
- 算法评价 = 不同运行时间 & 存储空间效率 = 不同逻辑结构 + 不同存储结构 + 不同运算方法
  - 时间复杂度O(n)：所有语句频度之和的数量级 = 最深层循环内的语句的频度数量级
  	- O(1) ＜ O(log₂(n)) ＜ O(n) ＜ O(nlog₂(n)) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!) ＜ O(n^n)
    - 最内层语句**执行次数**的频度，如 设执行t次，若2^t≤n，则t≤log₂(n)，时间复杂度为O(log₂(n))
  - 空间复杂度O(n)：耗费存储空间，原地工作-辅助空间为常量-即O(1)
  - 排序算法的稳定性

# 二、线性表
- 数据表由数据元素组成，数据元素由一个整数or一个实数or一个字符or一个字符串or若干个数据项组成
  - 数据元素 = 结点 = 记录，数据项 = 字段 = 域，键 = 关键字 = 能唯一标识结点的字段
- 存储结构：顺序、链式
- 顺序存储：顺序表
  - 无序O(n)，有序折半O(log₂(n))，序号O(1)——数组
  - 逻辑相连，地址相连，数据存储在一组连续的地址中
  - 可随机存取，存储空间较固定，增删慢，无法扩容
  - 插入、删除、连带许多元素的移动
- 链式存储：链表
  - 单链表O(n)，双链表O(n)，循环链表——指针
  - 静态链表——数组下标 replace 指针
  - 各结点之间逻辑相连，地址随机，结点内变量地址连续，链表节点为结构体定义
  - 只顺序存取，存储空间不固定，带头结点and不带头结点
  - 插入、删除、合并，头插法（实现逆序）、尾插法

# 三、队列、栈——限定了一定操作的线性表
- 存储结构：顺序、链式
- 栈
  - 顺序栈：int top，顺序存储——括号匹配
  - 链栈：head→，链式存储——后缀表达式求值
  - 共享栈/双向栈：两个栈共享一个一维数据空间，栈底分别在空间的两端，递归
  - 应用：实现逆序，递归算法的非递归实现，数据输入输出的顺序分析，算术运算表达式-前中后缀，括号匹配，树的深度遍历
  	- 括号匹配，如 顺序扫描，遇左括号则入栈，遇右括号则判断是否与栈顶左括号配对，是则匹配出栈，否则不匹配
  	- 后缀表达式求值，顺序扫描，遇数则入栈，遇操作符op则出栈两个数，计算结果 = 后出op先出，结果入栈，最后栈顶为最终结果
- 队列
  - 头尾指针配置，队满队空判断
  - 顺序队列，主机&外设的速度不匹配
  - 循环队列，取余表示，多用户引起的资源竞争，队满队空判断（3种）
    - 牺牲一个单元，队满 = 头指针在尾指针的下一个位置 Q.front = (Q.rear+1) % MAXSIZE，队空 头 = 尾
    - 类型中加上数据成员表示元素个数，队满 Q.size = MAXSIZE，队空 Q.size = 0
    - 类型中加上标志位tag，队满 tag = 1 且 插入导致 头 = 尾，队空 tag = 0 且 删除导致 头 = 尾
  - 链式队列，同时带头尾指针的单链表
  - 双端队列，两端均可出队、入队，某端可限制操作
  - 应用总结：树的层次遍历，解决多用户引起的CPU资源竞争问题（操作系统OS相关），缓冲区队列-解决计算机和外设间速度不匹配问题
- 矩阵
  - 特殊矩阵：稀疏矩阵，上下三角矩阵，n对角矩阵，堆成矩阵
  - 存储：按行or按列优先
  - 特殊矩阵的压缩存储：对称矩阵，稀疏矩阵
- 广义表
  - 深度-括号最大层数，长度-最上层元素个数，GetHead() GetTail()

# 四、树 二叉树
- 存储结构：顺序、链式
- n个结点，n-1条边，高度 = 层数，根为第1层
- 结点的度 = m = 该结点的子结点个数，第i层结点数 = m^(i-1)，树的度 = max(m)
- 高 = h 的m叉树，结点最多 = 1 + m + m^2 + ... + m^(i-1) = (1-m^h)/(1-m)
- 路径长度：路径上所经过的边的个数，路径：两个结点间经过的结点序列
- 平衡因子：左子树 - 右子树？？？的高度差
## 二叉树
- 顺序存储，链式存储
  - 链式：n个结点-n+1个空链域，结点 = 数据data域 + 左指针lchild + 右指针rchild
  - 叶节点空指针N₂ + 度为1的结点空指针N₁
- 遍历：X序+中序，确定一个二叉树
  - 深度遍历
    - 先序 = 根左右，中序 = 左根右，后序 = 左右根，X序 = 根在X位置
    - 时间复杂度均 O(n)，空间复杂度均 O(n)
    - 递归转非递归：栈，就是思考的排序的顺序的逆过程，
      - 如 中序，序列为213，如何得到这个序列，
      - 根入栈，沿着左边一路将左结点们全部入栈，后出栈一个，访问之，将之的直接右孩子进栈，再将该右孩子的所有左结点入栈，循环
  - 层次遍历：借助队列，根先入队，根出队访问后将根的左右孩子入队，如此循环，即 将 出队列的结点的左右孩子 按顺序入队
- 满二叉树：每层都含有最多的结点数，高 = n，结点 = 2^n - 1，
- 完全二叉树：结点从上到下、从左到右按顺序填充下来，中间不能跳，只有最后一层靠右侧可不满，只有最后两层靠右侧可能有叶子结点
- 线索二叉树：利用结点中的空指针，加上线索的二叉树
  - 结点 = 数据域data + 左指针lchild + 左标志ltag + 右指针rchild + 右标志rtag
  - ltag = 0 → lchild指向左孩子，ltag = 1 → lchile指向结点前驱
  - rtag = 0 → rchile指向右孩子，rtag = 1 → rchild指向结点后继
- 二叉排序树/二叉查找树 BTS树
  - 左子树结点 ＜ 根结点 ＜ 右子树结点
  - 插入：递归，原树（结点）为空则插入，小于当前则则插入左子树，大则插入右子树
  - 删除：删除后依然需要具有二叉排序树的左小右大性质，需按情况调整被删结点周围的子树位置
  - 平均查找长度取决于高h，单支 = O(n)，平衡 =  O(log(2)n)
- 平衡二叉树 AVL树
  - 本质是二叉排序树，Δh≤1，即 任一结点的左子树和右子树的深度之差≤1
  - 旋转：插入or删除后调整最小不平衡子树
    - LL平衡旋转/右单旋转：结点A的左孩子的左子树中插入，需要A向右旋转一次
    - RR-左单旋转：结点A的右孩子的右子树中插入，需A左旋转一次
    - LR-先左后右：结点A的左孩子的右子树中插入，先左转左子树，再右转A结点
    - RL-先右后左：结点A的右孩子的左子树中插入，先右转右子树，再左转A结点
  - 大一统调整
    - 找到要做平衡调整的三个点：从 离插入点最近的不平衡节点，到 插入点的路径 上的头三个点
    - 中序遍历（效果=从小到大排序），该三点中处于中间的点 作为要调整的子树的根节点（三点含原树根节点也一样的调整）
    - 重新排好三个点后，其他点的位置照搬，搬不了的按正常顺序插入
  - 平均查找长度O(log₂n)
- 最优二叉树/哈弗曼树 Huffman
  - 生成：在森林中，找权值最小的两个根结点的树作为新结点的左、右子树，新结点权值 = 左子树的根权值 + 右子树的根权值，以此类推，即 所求元素都在叶节点上
  - 哈弗曼编码：前缀编码，不等长/可变长编码-节省空间
  - 最优带权路径长度 WPL = ∑权值 x 路经min长，带权路径长度 = ∑权值 x 路径长
  - n个结点造huffman，共出2n-1个点，新建n-1个点
  - k叉树按规则补空白节点
  - 哈弗曼编码
    - 数据压缩编码，频率高的字符赋以短码，频率低的赋以较长码
    - 构造：标记对哈弗曼树的边，连左孩子的标0，右孩子的标1，其WPL即为得到的二进制编码长度
- 树：并查集
- 算术表达式的生成、求解
- 二叉树的估计
## 树 森林
- 与二叉树之间的转化：左子树对应兄弟，右子树对应子女
- 树
  - 双亲表示：结点 = data域 + 父结点位置域
  - 孩子表示：每个结点的孩子都用单链表连起来
  - 孩子兄弟表示：二叉链表，结点 = data + 指向第一个孩子结点的指针 + 指向下一个兄弟结点的指针
  - 遍历：先根（类比先序），后根（类比中序）
  - 应用：并查集
- 森林：先序，中序

# 五、图
- 图最少有一个顶点，不可为空图
- 图的阶：图中的顶点个数，设图有n个顶点
- 无向图-连通性
  - 顶点的度：与顶点直连的边的条数
  - 连通分量 = 极大连通子图，含all边，v - w
  - 非连通图的边＜n-1，否则是有环的非连通图
- 有向图-强连通性
  - 入度、出度：以顶点为终点、起点的有向边条数
  - 强连通分量 = 极大强连通图，含all边，v(尾) →w(头) →v
- 连通图：任意两个顶点都是联通的（对应无向图）
  - 连通分量：该图的极大联通子图，注：极小连通子图为边数最少，可由最小生成树得到
- 强连通图：任意两个顶点都是强连通的（对应有向图）
  - 强连通：两个顶点互相到对方都有路径
  - 强连通分量：有向图的极大强连通子图
- 简单图：无重复边，无顶点到自身边
- 多重图：有重复边，允许顶点有自身边
- 完全图：任意两个顶点之间都存在边（无向图）or方向相反两条弧（有向图）
  - 无向完全图，n个顶点，n*(n-1)/2条边
  - 有向完全图，n个顶点，n*(n-1)条有向边
- 子图：边与顶点对应，不是任何原图成员都能构成
- 网：带权图，即边上带权值的图
- 路径：顶点v到w的顶点序列，路径长度：路径上边的数目，简单路径：顶点不重复
- 距离：最短路径的长度
- 环/回路：n个顶点，大于n-1条边，必有环
## 物理存储（设结点数 n 边数 e）
- 邻接矩阵
  - 表示唯一，多用于存稠密图，顺序存储，n*n 矩阵，如二维数组，空间O(n^2)
  - A[i][j] = 1 or 权值，为点i到点j有边；0 or ∞，为无边
- 邻接表
  - 表示可能不同，多用于存稀疏图，链接存储，空间无向O(n+2e)，空间有向O(n+e)
  - 为每个顶点Vi建立一个单链表，而头指针+顶点们的信息存于顶点表（顺序表）H[]
  - 即 顶点表结点 = 顶点域 + 边表头指针，边表结点 = 邻接点域 + 指针域
  ~~~
  顶点H[1] →顶点1的第一条边连向的顶点2 →顶点1连的第二条边连向顶点4...
  顶点H[2] →顶点2的第一条边连向顶点4...
  顶点H[3] →...
  ~~~
- 十字链表
  - 有向图，链式存储，顶点结点顺序存储
  - 弧结点：info域，headvex头域指示弧头顶点位置，tailvex尾域指示弧尾顶点位置，hlink指针指向弧头相同的下一条弧，tlink指向弧尾相同的下一条弧
  - 顶点结点：data域，firstin指针指向以该顶点为弧头的第一个弧结点，firstout指针指向以该顶点为弧尾的第一个弧结点
- 邻接多重表
  - 无向图，链式存储，顶点结点顺序存储
  - 边表结点：info域，mark标志位该边是否被搜索过，ivex和jvex指示该边连的两顶点位置，ilink指向下一条依附于ivex的边，jlink指向jvex的
  - 顶点结点：data域，firstedge指示第一条依附于该顶点的边
## 遍历
- 广度优先 BFS Breadth-First-Search
  - 思路：先访问某起始顶点v，然后依次访v的未访过的邻接点们w1 w2...，然后依次访w1 w2 ...们的未访过的邻接点们，类推，直到访完
  - 由已知顶点出发，依次访问已知点的未访问过的邻接点
    - 类似层次遍历、Dijkstra 单源最短路径算法、Prim 最小生成树算法
    - 单源最短路径：按距离由近到远遍历
  - 辅助：队列Q类似层次遍历地用来控制访问的结点，数组visit[i]标志顶点vi是否被访问过
  - 空间O(n)时（每个结点都要入队一次），邻接表矩阵O(n^2)，邻接表O(n+e)
- 深度优先 DFS Depth-First-Search
  - 思路：先访问某起始顶点v，然后访v的任一未访邻接点w，再访w的任一未访x，类推，直到底，后退回最近被访的顶点，找其他未访邻接点
  - 从已知顶点出发，访问任一未访邻点，接着访问该未访邻点的任一未访邻点，以此类推，直到无退回，再访
    - 类似先序遍历
    - 判断回路：一次访问完all点？
  - 空间O(n)时，邻接表矩阵O(n^2)，邻接表O(n+e)
- 连通性：遍历图来判断，一次遍历即能访到所有点即为连通or强连通
## 应用
- 最小生成树 MST Minimum-Spanning-Tree span-范围
  - 是极小连通子图，树型不唯一，包含all顶点，边的权值之和最小，边数 = 顶点 - 1 = n - 1
  - 利用性质：设G=(V,E)是一个带权连通无向图，U是结点集V的子集，(u,v)是一条最小权值的边，u∈U，v∈V-U，则必存在包含该边的MST
  - 基于贪心算法策略：每趟都找到当前局部最优解
  - 算法思路：T未形成一颗生成树时，找到一条最小代价边加入T且不产生回路，循环直到T成
  - 普利姆 Prim 算法
    - 适用于稠密图，从顶点集开始分析，以顶点合并完为准，时间O(n^2)
    - 从已有点的集合出发，从通向还未合并的点的路径们中，找到权值最小的边、该边连着的点，访问且合并到已有点集，直到点都并完
    - 顺着来，从已有出发，在和已有点连着的边里，找 连着未连点的边 中的最小边，并入
  - 克鲁斯卡尔 Kruskal 算法
    - 适用于稀疏图，用边连接两个顶点开始分析，以 边数 = n - 1 为准，时间O(e*loge)
    - 从未合并的边集和出发，从未合并的边中找权值最小的边，看他连起来后，和已有树们不构成回路，则合并到已有边集，直到边=n-1
    - 乱序生成，只看哪条边最小，且加入不成环，并入
- 最短路径
  - 点to点，路径权值min
  - 单源到各顶点最短：迪杰斯特拉 Dijkstra 单源最短路径算法
    - 时间O(n^2)，找源点to其他各点的路径和路径长度
    - 借助表寻找，横表头为第几趟寻找，纵表头为除源点的顶点列表，表内为该趟找到的、源点通向每个顶点的路径们
      - 每条路径都从源点开始，经过已有点的集合（已有点内构成的路径可能不止一条），分别找通向每个未合并的点 的路径们
      - 找到这些路径们中路径权值（即权值和）最小的路径、路径对应的未合并点，访问且合并到已有点集，记录路径长度，直到点都并完
    - 若有 权值＜0 的边，则可能无法得到正确结果
  - 任意两两顶点最短：弗洛伊德 Floyd 各顶点最短路径算法
    - 时间O(n^3)，找各个顶点互相之间的最短路径和路径长度，长度存在A(n-1)矩阵中
    - 构造n*n矩阵A寻找，迭代插点，方阵更替，变化矩阵内部内容，A(-1) A(0) A(1) ... A(n-1)
      - 初始A(-1)即该图的邻接矩阵，每迭代一次，从Vi到Vj的最短路径中多考虑一个顶点Vk，看和原路径比谁更短，k从0递增
      - A[i][j] = 点i到点j的 边权值 or 路径权值和，A(-1)初始化，A(k)[i][j] = min { A(k-1)[i][j], A(k-1)[i][k] + A(k-1)[k][j] }
    - 允许负权值边，不允许负权值边组成回路
- 拓扑排序
  - DAG图 有向无环图 Directed-Acyclic-Graph
    - 活动序列 = DAG的所有点输出的序列
  - AOV网 Activity-On-Vertex-Network
    - AOV网 = 顶点代表活动的DAG图，有向边表活动先后顺序，vertex-顶点，活动只能按顺序来
  - 拓扑排序：DAG图的all顶点组成的一个满足条件的序列，拓扑排序不唯一
    - 排出的顺序 = 边指向顺序，即 Vi→Vj，则排序Vi必在Vj前
    - 排序步骤：找无前驱的顶点为起点，输出之，再去掉该顶点和该顶点连的边们，找下一个顶点
    - 矩阵O(n^2+e)，表(n+e)，算法利用栈，入度=0则该顶点入栈，时间O(n+e)
- 关键路径
  - AOE网 Activity-On-Edge-Network
    - AOE网 = 带权有向图，顶点表示事件，边表示活动，权值表示活动开销，edge-边
    - AOE只有一个源点（入度=0），一个汇点（出度=0），中间全是过程的顶点
  - 性质（理解关键路径的基础）
    - 只有事件发生后，该事件后的活动才能开始；只有事件前的 all活动 都完成后，该事件才能开始
  - 关键路径：从源点到汇点的all路径中，具有最大路径长度（权值）的路径。关键路径上的活动为关键活动，关键路径的开销 = 完成整个工程的最短时间
  - 找关键活动
    - 顶点 = 事件，边 = 活动，事件Vi to 事件Vj，中间经过 活动K
    - 事件最早发生 = max { 直接前驱事件最早 + 活动持续 }
    - 事件最迟发生 = min { 直接后继事件最迟 - 活动持续 }
    - 活动最早开始 = 活动起点的事件的最早发生时间
    - 活动最迟开始 = 活动终点的事件的最迟发生时间 - 活动时间
    - 关键活动条件：活动最早 = 活动最迟，即活动只能在一个时间开始
  - 桥：
  - 关键路径上提高效率，才可能提升整体效率

# 六、查找
- 查找表——用于查找的数据集合，静态——不插入不删除不修改查找表，动态——需要动态地插入or删除
- 静态适合：顺序，折半，散列
- 动态适合：二叉排序树，散列，二叉平衡，B树
- 平均查找长度 ASL Average-Search-Length
  - 设 n = 表长，Pi = 找第i个元素的概率-默认均值1/n，Ci = 找到第i个元素进行的比较次数
  - ASL = ∑Pi ·Ci = 所有可能过程中，关键字比较次数的平均值
## 线性结构
- 顺序查找：逐个检索
  - 线性表：ASL成功 = (n+1)/2，ASL失败 = n + 1
  - 有序表：ASL成功 = (n+1)/2，ASL失败 = n/2 + n/(n+1)
- 折半/二分查找：low，high，mid
  - 只用于有序顺序表，过程-判定树（平衡二叉树），时O(log(2)n)
  - ASL成功 = (n+1)/n ·log(2)(n+1) ≈log(2)(n+1) - 1
- 分块查找：索引+顺序
  - ASL成功 = ASL索引 + ASL块内
  - 索引元素需有序，查找方法不定；块内元素可无序，按顺序查找
## 树查找
- 二叉排序树
- 二叉平衡树
- B树
  - 本质：平衡因子 = 0 的多路平衡查找树（即每颗子树一样高）
  - m 阶：每个结点内最多 m-1 个、最少 (m/2)-1向上取整 个关键字，每个结点下最多m个子树，除根外最少(m/2)的向上取整个子树
  - 结点结构：{n P0 K1 P1 K2 P2 ...}
    - n为结点中关键字的个数，Ki为关键字-左小右大，Pi指向儿子
    - 限定条件：根结点和非叶结点的关键字个数，子树个数的限定范围
  - 一颗m阶B树高为h，有 log(m)(n+1) ≤ h ≤ log(m/2)((n+1)/2) + 1
  - 查找：①在B树中找结点（磁盘操作）；②在结点内找关键字（内存操作）
    - 查找时，非叶节点、叶节点 均可包含数据，一般叶节点不含数据？
  - 操作：破坏B树被操作结点的最大最小值，则需变化
    - 插入：插入结点后关键字多了，从结点中间进行分裂
    - 删除：非叶结点——子树最大/小的关键字挪上来，叶结点——兄弟的父子顺移，兄弟不够则先并兄弟再并父母
  - 常用：文件在内存、磁盘的分层查找
- B+树
  - m 阶：每个结点内最多 m 个、最少 (m/2)向上取整个 关键字，关键字个数 = 子树个数
  - 非叶节点 = 索引作用，常用于数据库，限定条件，与B树的区别
  - 叶节点包含数据，非叶节点仅为索引，非叶节点关键字 = 其对应子结点关键字的最大值
- 红黑树
## 散列表（Hash表）
- 散列、杂凑，或音译为哈希：通过散列算法，把任意长度的输入变换成固定长度的输出
- 适用情况：直接映射，效率高；数据量多，需要快速查找定位
- 散列函数 Hash(key)：Addr = Hash(key) = H(key)
  - 把查找表中的关键字映射为该关键字对应的存放地址Addr
  - Addr =｛数组下标、索引、内存地址……｝
  - 冲突：Hash(key1) = Hash(key2)=... 两个或以上关键字映射到同一地址
  - 同义词：key1 key2 发生碰撞的不同关键字，为一组同义词
- 散列表：一种数据结构，根据关键字直接进行访问
- 查找性能理想情况O(1)，查找效率 = 装填因子 + 散列函数 + 处理冲突方法
  - ASL 取决于 装填因子α，α= 表中记录数n/散列表长m，α↑则记录多容易冲突
- 散列函数构造
  - 直接定址法：H(key) = a*key + b，常用
    - 关键字的线性函数，适合分布基本连续的关键字，无冲突，易空间浪费
  - 除留余数法：H(key) = key % p = key mod p，常用
    - 关键字个数 = m，p一般选择≤m的最大质数
  - 数字分析法：H(key) = 数码分部均匀的若干位？？？
    - 适合已知的关键字合集
  - 平方取中法：H(key) = key^2的中间几位
    - 具体几位看情况，适合关键字每一位都不够均匀or均小于散列地址所需位数
  - 折叠法：H(key) = 关键字分割成的位数相同的几部分的叠加和
    - 适合关键字位数多，每一位上数字分布均匀
### 解决冲突：开放定址法，拉链法
- 开放定址法
  - 公式：Hi = ( H(key) + di ) % m
    - Hi = 发生冲突后第i次探测的Addr，di = Δ增量序列，m = 关键字个数，i = 1,2,...,k(k≤m-1)
    - 允许同义词标中的地址和正常计算的非同义词地址发生冲突，可存放新表项的空闲地址向同义词+非同义词开放
  - 线性探测：di = 1，2，…，m-1
    - 从冲突地址开始顺序查表中的下一个单元，当查到m-1时，下一个是表首地址0
  - 平方探测/二次探测：di = 1^2，-1^2，2^2，-2^2，…，k^2，-k^2
    - k≤m/2，m为质数且m可表示为4k+3。此m是表长否？？？k是di里的k否？？？
    - 避免“堆积”问题，不能探测散列表所有单元，至少可以探测一半
  - 再散列/双散列法：di = Hash2(key)
    - 最多 m-1 次可遍历表中所有位置，回到H0位置
  - 伪随机序列法：di = 伪随机数序列
  - 建立公共溢出区？？？
  - 堆积问题：同义词冲突的探查序列，和非同义词之间不同的探查序列，交织→关键字查询需要较长的探测距离，降低散列的效率。？？
  - 不可随便物理删除表中的已有元素，会截断其他冲突元素的查找地址
- 拉链法/链地址法
  - 一组同义词存储于一个线性链表，这组同义词的散列地址对该链表进行唯一标识
  - 避免同义词和非同义词冲突，适合经常插入、删除的情况，操作主要在同义词链中进行
    - eg：假设Addr=i的同义词链表头指针，存在散列表的第i个单元中。关键字序列key={10,23,32,55}，散列函H(key)=key%3，(表长=4)
    - 则通过H(key)分别得到散列地址1，2，2，1，假设Addr=数组下标，散列表为HH[4]，则HH[1]中存储同义词10、55的链表头指针，链表第一个元素为10，第二个为55
      HH[0]^
      HH[1]→10→55
      HH[2]→23→32
      HH[3]^
## 字符串模式匹配 KMP Knuth-Morris-Pratt Algorithm
- 串的模式匹配：求第一个字符串（模式串）在第二个字符串（主串）中的位置
- 主串指针不回溯，next数组，模式串的指针依据next数组滑动，避免无意义比较
- 改进 KMP，nextval数组


# 七、排序
- 大多适用于顺序存储的线性表
- 稳定性：设数列中存在a[i]=a[j]，排序之后a[i]和a[j]的相对位置不变，则算法稳定
- 外部排序：排序时元素必须根据需求不断在内存、外存中移动，如多路归并
- 内部排序：排序时元素全在内存中，如下
## 插入
- 直接插入：顺序扫描，顺序比较当前元素和它之前的有序子表，找到位置，插入
  - 表L状态：{有序L[l-(i-1)]，Li，无序剩余L}
- 折半插入：比较当前元素和有序子表时，用折半查找确定元素位置，其余=直接插入
- 希尔排序：分割若干子表L[i, i+d, i+2d, ...]
  - 子表内先排序（原版方法是直接插入排序）
  - 步长d1时子表都有序后，取d2＜d1（通常dk=dk/2），再对d2时的子表们排序，直到di=1
## 交换
- 冒泡排序：每一趟内两两比较相邻元素，最多n-1趟排完
- 快速排序：平均性能最优，递归求解，L[]，low，high
  - 分治法：任取一个元素k为枢值（一般选当前子表的第一个元素），将表中小于k的放到k前，大于k的放到k后
  - 递归：表L进行一趟分治，分为左子表和右子表，枢值k；再将L左右子表分别分治，即产生递归
  - 跳出条件：已经不存在没分治过的子表，即 low == high
  - 一趟分治：输入要分治的表 L[]，表头位置 low，表尾位置 high
    - 比如 选第一个元素为枢值mid，左右来回扫数和枢值比较，找到一个要换的数，和枢值换，之后改变扫描方向
    - 效果：小于枢值放左边、大于的从右开始放（即交换元素），最后返回枢值mid的位置
    - 枢值的选取理论上可以随机，如随机选，有利于提高快排效率
## 选择（不稳）
- 简单选择：表L = {有序L[] ~ Li ~ 无序剩余L}，在无序中找min的与该位置Li交换，一趟找出一个无序子表中最小的
- 堆排序  ：将L[]看成一颗完全二叉树的顺序存储结构，排序过程=调整初始树为堆，即构造有序完全二叉树
  - 堆L[n]：L(i)≤L(2i)且L(i)≤L(2i+1)——小根堆，反过来即大根堆，堆=满足条件的完全二叉树
  - 即 小根堆-根最小-双亲≤孩子，大根堆-根最大-双亲≥孩子
  - 排序：从下往上逐步调整，从树底向树顶，如大根堆，若当前父母小于子女，将父母和子女位置交换，再看下一个父母。每趟子树根结点位置 = i/2 - 1 的向下取整，初始 i = n
  - 用途：实现优先级队列
## 归并、基数
- 归并排序：将≥2个的有序表组合为一个新的有序表，将n个元素的待排序表看成n个有序子表
  - 排序操作：low＜high时，取mid划分表，递归进行排序
    - 将传入递归函数的表从中间划为两子表，后将两子表分别递归排序，后将已排序的两子表进行归并操作
  - 归并操作：归并函数内合并两个表，使用辅助数组正常排序
  - 一趟时间O(n)，共log₂n趟
  - 二路归并 = 两两归并
- 基数排序：多关键字，按关键字的每个数位排序
  - 如先按个位排序，然后再按十位排序，最后百位
  - 不需要元素间比较
## 以上为内部排序
算法     |稳定性|平均时O()     |平均空O(1) |备注
---------|------|--------------|------------|----
--插入---|------|--------------|------------|√表示稳定or空间O(1) 表长 = n
直接插入 |√    |O(n²)        |√
折半插入 |√    |O(n²)        |√
希尔排序 |不稳  |O(n^(1.3))    |√          |实际时间O依赖于增量函数
--交换---|------|--------------|------------
冒泡排序 |√    |O(n²)        |√          |一趟一个最终位置
快速排序 |不稳  |O(n * log₂n) |O(log₂n)栈 |一趟一个最终位置 最坏时间O(n²) 最坏空间O(n)
--选择---|------|--------------|------------
简单选择 |不稳  |O(n²)        |√          |一趟一个最终位置
堆排序   |不稳  |O(n * log₂n) |√          |一趟一个最终位置 有序完全二叉树
---------|------|--------------|------------
二路归并 |√    |O(n * log₂n) |O(n)
---------|------|--------------|------------
基数排序 |√    |O[d(n+r)]     |O(r)队列    |趟数 = d

## 外部排序
- 排序文件较大，内存一次放不下，文件需存放在外部介质
- 核心耗时：I/O存取
- 核心问题：内存空间有限
- 多路平衡归并
  - 一整套解决方案
  - m路归并：减少I/O费时
  - 败者树：抵消m增多对比较次数的影响
  - 置换-选择：增大归并段长，生成不同长度段以减小趟数
  - 最佳归并树：m叉树，减少I/O访问次数，最短带权路径长度WPL
## 其他
- 睡眠排序
  - 根据CPU的调度算法实现——讲cup调度算法？？
  - 对一组数据进行排序，不能存在负数值，这个数是多大，那么就在线程里睡眠它的10倍再加10
  - 睡眠和它的数值不一样大的原因：当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果
  - 利用栈，醒一个入栈一个，出栈可得倒序结果

# 串


# 八、其他
## 筛子算法 Erat osthenes
最早计算素数个数的算法

