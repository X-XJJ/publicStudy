结合图像理解！！脑子里要有动态图、过程图！！

# 一、基本概念
- 数据结构：数据元素的集合，这些元素相互之间存在一种or多种特定的关系
  - 数据结构 = 数据元素 + 逻辑关系
- 三要素：逻辑结构，物理结构，数据的运算
- 逻辑结构：数据之间逻辑关系的描述
  - 线性：线性表、栈、队列
  - 非线性：树、图、集合
- 存储结构/物理结构：逻辑结构在计算机中的表示
  - 顺序、链式、索引、散列（哈希）
- 对数据进行各种非数值运算：查找、排序、插入、删除、修改、遍历
- 算法：指令的有穷序列，有穷、确定、可行、输入、输出
- 算法评价 = 不同运行时间 & 存储空间效率 = 不同逻辑结构 + 不同存储结构 + 不同运算方法
  - 时间复杂度O(n)：所有语句频度之和的**数量级** = 最深层循环内的语句的频度数量级
  	- O(1) ＜ O(log₂(n)) ＜ O(n) ＜ O(nlog₂(n)) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!) ＜ O(n^n)
    - 最内层语句**执行次数**的频度，如 设执行t次，若2^t≤n，则t≤log₂(n)，时间复杂度为O(log₂(n))
  - 空间复杂度O(n)：耗费存储空间，原地工作 = 辅助空间为常量 = O(1)
  - 排序算法的稳定性

# 二、线性表
- 数据表由数据元素组成，数据元素由一个整数or一个实数or一个字符or一个字符串or若干个数据项组成
  - 数据元素 = 结点 = 记录，数据项 = 字段 = 域，键 = 关键字 = 能唯一标识结点的字段
- 存储结构：顺序、链式
- 顺序存储：顺序表
  - 无序O(n)，有序折半O(log₂(n))，序号O(1)——用数组
  - 逻辑相连，地址相连，数据存储在一组连续的地址中
  - 可随机存取，存储空间较固定，增删慢，一般不能扩容
  - 插入、删除、连带许多元素的移动
- 链式存储：链表
  - 单链表O(n)，双链表O(n)，循环链表——用指针
  - 静态链表——数组下标 replace 指针
  - 各结点之间逻辑相连，地址随机，单个结点内的变量地址连续，链表结点为结构体定义
  - 只能顺序存取，存储空间不固定，带头结点and不带头结点
  - 插入、删除、合并，头插法（实现逆序）、尾插法

# 三、队列、栈——限定了一定操作的线性表
- 存储结构：顺序、链式
- 栈：先进后出
  - 顺序栈：int top，顺序存储——括号匹配
  - 链栈：head→，链式存储——后缀表达式求值
  - 共享栈/双向栈：两个栈共享一个一维数据空间，栈底分别在空间的两端，递归
  - 应用：逆序，递归算法的非递归实现，数据输入输出的顺序分析，算术运算表达式-前中后缀，括号匹配，树的深度遍历
  	- 括号匹配，如 顺序扫描，遇左括号则入栈，遇右括号则判断是否与栈顶左括号配对，是则匹配出栈，否则不匹配
  	- 后缀表达式求值，顺序扫描，遇数则入栈，遇操作符op则出栈两个数，计算结果 = 后出op先出，结果入栈，最后栈顶为最终结果
- 队列：先进先出
  - 头尾指针配置，队满队空判断
  - 顺序队列，主机&外设的速度不匹配
  - 循环队列，取余表示，多用户引起的资源竞争，队满队空判断（3种）
    - 牺牲一个单元，队满 = 头指针在尾指针的下一个位置 Q.front = (Q.rear+1) % MAXSIZE，队空 头 = 尾
    - 类型中加上数据成员表示元素个数，队满 Q.size = MAXSIZE，队空 Q.size = 0
    - 类型中加上标志位tag，队满 tag = 1 且 插入导致 头 = 尾，队空 tag = 0 且 删除导致 头 = 尾
  - 链式队列，同时带头尾指针的单链表
  - 双端队列，两端均可出队、入队，某端可限制操作
  - 应用：树的层次遍历，解决多用户引起的CPU资源竞争问题（操作系统OS相关），缓冲区队列-解决计算机和外设间速度不匹配问题
- 矩阵
  - 多维数组存储
    - 方式：按行优先or按列优先，稀疏矩阵用三元组
    - 逻辑数组，物理上是顺序存储，占用一段连续的存储空间
  - 压缩存储：对矩阵中有相同值的多个元素只分配一个存储空间，零元素不分配存储空间
  - 特殊矩阵：矩阵内存在多个相同元素or零元素，且分布有一定规律
    - n阶方阵：A(nxn)形如[\]，从左到右划为 下三角区、主对角线i=j、上三角区
      - 对称矩阵：满足a(ij)=a(ji)，只存主对角线、下三角区
      - 下三角矩阵：下三角区、主对角线元素不同，上三角区元素都为同一常量，只存下三角、主对角、最后加一个上三角的常量
      - 上三角矩阵：下三角反过来即是
      - n对角矩阵（带状矩阵）：元素集中在以主对角线为中心、上下对等的对角线区域，其他地方元素为0，只存对角线们
    - 稀疏矩阵：0特多，用三元组（行标i，列标j，值）只存非零元素，压缩后失去“随机存取”特性
    - 堆成矩阵
- 广义表
  - 深度-括号最大层数，长度-最上层元素个数，GetHead() GetTail()

# 四、树 二叉树
- 存储结构：顺序、链式
- 结点的度 m = 该结点的子结点个数，也即 从该结点射出的边的条数
- 设树中 度为i的结点个数为Ni
- 设一棵树有 n 个结点，则它有 n-1 条边，高度 = 层数，根为第1层
  - n = N0 + N1 +…+Ni = 边数 + 1 = (0×N0 + 1×N1 + 2×N2 + 3×N3 +…+ i×Ni) + 1
- 第i层结点数 = m^(i-1)，树的度 = max(m)
- 高 = h 的m叉树，结点最多 = 1 + m + m^2 + ... + m^(i-1) = (1-m^h)/(1-m)
- 路径：两个结点间经过的结点序列
- 路径长度：路径上经过的边的个数
- 平衡因子：左子树 - 右子树？？？的高度差
## 二叉树
- 非空二叉树的结点总数 N = N0 + N1 + N2 = 边数 + 1 = (0×N0 + 1×N1 + 2×N2) + 1
  - 即 N0 = N2 + 1 （N2 = N0 - 1）
- 顺序存储，链式存储
  - 顺序存储：从上到下、从左到右存入一维空间，按完全二叉树来存、空位补0，用数组下标表示结点间的父子关系
  - 链式存储：n个结点 对应 n+1个空链域
  - 结点结构 = { 左指针 lchild | 数据域 data | 右指针 rchild }
  - 叶节点空指针N₂ + 度为1的结点空指针N₁
- 遍历：X序+中序，确定一个二叉树
  - 深度遍历
    - 先序 = 根左右，中序 = 左根右，后序 = 左右根，X序 = 根在X位置
    - 时间复杂度均 O(n)，空间复杂度均 O(n)
    - 递归转非递归：栈，就是思考的排序的顺序的逆过程，
      - 如 中序，序列为213，如何得到这个序列，
      - 根入栈，沿着左边一路将左结点们全部入栈，后出栈一个，访问之，将之的直接右孩子进栈，再将该右孩子的所有左结点入栈，循环
  - 层次遍历：借助队列，根先入队，根出队访问后将根的左右孩子入队，如此循环，即 将 出队列的结点的左右孩子 按顺序入队
- 满二叉树：每层都含有最多的结点数，高 = h，结点 n = 2^h - 1
- 完全二叉树：结点从上到下、从左到右按顺序填充下来，中间不能跳，只有最后一层靠右侧可不满，只有最后两层靠右侧可能有叶子结点
- 堆：一类特殊的树，特点是父结点一定大于or小于它所有的子结点，通常使用满足条件的完全二叉树以便于存储
- 线索二叉树：利用结点中的空指针，加上线索的二叉树
  - 结点 = 数据域 data + 左指针 lchild + 左标志 ltag + 右指针 rchild + 右标志 rtag
  - 线索化
    - 在遍历的过程中修改空指针，即将二叉链表中的空指针改为指向前趋or后继
    - 附加一个始终指向刚刚访问过的结点的指针pre，p指向当前访问的结点，则pre指向p的前趋
  - 规则：0孩子，1线索
    - ltag = 0：lchild指向左孩子，ltag = 1：lchile指向结点前驱
    - rtag = 0：rchile指向右孩子，rtag = 1：rchild指向结点后继
  - 注意！前趋、后继 是针对X序遍历序列中的结点来说的，不是指结点的父子结点，如 某中序序列是 acbde，则b的前趋是C，后继是d
  - 线索二叉树中找结点A的前趋、后继
    - 中序线索二叉树（左根右）
      - 找前趋：ltag==1 按线索找；ltag!=1 前趋是A点的左子树中最右下的结点，即 遍历A点左子树时最后访问的结点
      - 找后继：rtag==1 按线索找；rtag!=1 后继是A点的右子树中最左下的结点，即 中序遍历A点的右子树时访问的第一个结点
    - 后序线索二叉树（左右根）
      - 找前趋：ltag==1 按线索找；ltag!=1 前趋是？？ 
      - 找后继：rtag==1 按线索找；rtag!=1 有3种情况：①A是树根，无后继；②A是双亲的最后一个孩子 即A是右子树orA是左子树但双亲没有右子树，A后继是A双亲结点；③A是双亲的左子树且双亲有右子树，A后继是其右兄弟按后序遍历的第一个结点

- 二叉排序树/二叉查找树 BTS树
  - 左子树结点 ＜ 根结点 ＜ 右子树结点
  - 插入：递归，原树（结点）为空则插入，小于当前则则插入左子树，大则插入右子树
  - 删除：删除后依然需要具有二叉排序树的左小右大性质，需按情况调整被删结点周围的子树位置
  - 平均查找长度取决于高h，单支 = O(n)，平衡 =  O(log(2)n)
- 平衡二叉树 AVL树
  - 二叉排序树的特殊情况，Δh≤1，即 任一结点的左子树和右子树的深度之差≤1
  - 平均查找长度O(log₂n)
  - 旋转：插入or删除后调整最小不平衡子树
    - LL平衡旋转/右单旋转：结点A的左孩子的左子树中插入，需要A向右旋转一次
    - RR-左单旋转：结点A的右孩子的右子树中插入，需A左旋转一次
    - LR-先左后右：结点A的左孩子的右子树中插入，先左转左子树，再右转A结点
    - RL-先右后左：结点A的右孩子的左子树中插入，先右转右子树，再左转A结点
  - 大一统调整
    - 找到要做平衡调整的三个点：从 离插入点最近的不平衡结点 到 插入点 的路径上的头三个点，不平衡结点的左右子树差＞1
    - 对整个树进行 中序遍历（效果=从小到大排序），选出 找到的要调整的三个点中 处于中间大小的点，作为 根结点，另两个数一左一右（三点若含原树根结点也一样的调整）
    - 重新排好三个点后，其他点的位置照搬，搬不了的按正常顺序插入
    - ref：[平衡二叉树（AVL树） 调整 大一统 极简方法讲解](https://www.bilibili.com/video/BV13J411v73t)
- 最优二叉树 = 哈弗曼树 Huffman
  - 带权路径长度 = ∑权值 x 路径长
  - 最优带权路径长度 WPL = ∑权值 x 路经min长
  - 哈夫曼树生成：森林中，找两个根结点权值最小的树 作为新结点的左、右子树，新结点权值 = 左子树的根权值 + 右子树的根权值，以此类推，即 所求元素都在叶节点上
  - 按此构造方法，哈夫曼树没有度为1的结点，即只存在 N0 和 N2
  - 为 n 个字符（即叶结点）构造huffman，新建了 n-1 个结点（即N2），∴树共有 2n-1 个结点
  - k叉树按规则补空白节点
  - 哈弗曼编码
    - 被编码的字符存于叶结点，每个字符的编码对应于从根开始到某叶结点的一条路径
    - 构造：从根开始标记哈弗曼树的边，如约定连左孩子的边表示0，连右孩子的边表示1，路径长度WPL = 二进制编码长度
    - 是前缀编码，任一字符的编码都不是其他字符编码的前缀
      - 普通二叉树即可设计前缀编码，也可判定编码是否具有前缀特性
      - 哈弗曼树是优化，使编码总长度最小
      - 判定前缀特性：即判定存有字符信息的结点是否全部都是叶子节点，是则有前缀特性
        - 也可以是建立二叉树的过程，读入某字符编码并建立从根开始、对应于该编码的一条路径，若到最后一位时创建了新的叶结点，则此编码通过，开始下一个字符；否则，遇到叶结点or没有创建新结点，都不具备前缀特性
    - 是不等长/可变长编码，节省空间
    - 适合数据压缩编码，频率高的字符赋以短码，频率低的赋以较长码
- 树：并查集
- （有向）二叉树 运用于 算术表达式的生成、求解
  - 非叶结点-运算符，叶结点-操作数
  - 对应表达式：先序遍历-前缀，中序遍历-中缀（即通常形式），后续遍历-后缀
  - 有向二叉树可转化为有向无环图，来描述表达式 19年6题
- 二叉树的估计
## 树 森林
- 与二叉树之间的转化：左子树对应兄弟，右子树对应子女
- 树
  - 双亲表示：结点 = data域 + 父结点位置域
  - 孩子表示：每个结点的孩子都用单链表连起来
  - 孩子兄弟表示：二叉链表，结点 = data + 指向第一个孩子结点的指针 + 指向下一个兄弟结点的指针
  - 遍历
    - 先根：序列同先序，先访根再访其每个孩子
    - 后根：序列同中序，先访每个孩子再访其根
  - 应用：并查集
- 森林：先序，中序

# 五、图
- 图最少有一个顶点，不可为空图
- 图的阶：图中的顶点个数，设图有n个顶点
- 无向图-连通性
  - 顶点的度：与顶点直连的边的条数
  - 连通分量 = 极大连通子图，含all边，v - w
  - 非连通图的边＜n-1，否则是有环的非连通图
- 有向图-强连通性
  - 入度、出度：以顶点为终点、起点的有向边条数
  - 强连通分量 = 极大强连通图，含all边，v(尾) →w(头) →v
- 连通图：任意两个顶点都是联通的（对应无向图）
  - 连通分量：该图的极大联通子图
  - 极小连通子图：边数最少，可由最小生成树得到
  - ！注！
    - 无向图：极小连通子图，极大连通子图
    - 有向图：极大强连通子图，不存在极小强连通子图
- 强连通图：任意两个顶点都是强连通的（对应有向图）
  - 强连通：两个顶点互相到对方都有路径
  - 强连通分量：有向图的极大强连通子图
- 简单图：无重复边，无顶点到自身边
- 多重图：有重复边，允许顶点有自身边
- 完全图：任意两个顶点之间都存在边（无向图）or方向相反两条弧（有向图）
  - 无向完全图，n个顶点，n*(n-1)/2 条边（每个顶点都连着 n-1 条边）
  - 有向完全图，n个顶点，n*(n-1) 条有向边
- 子图：边与顶点对应，不是任何原图成员都能构成
- 网：带权图，即边上带权值的图
- 路径：顶点v到w的顶点序列，路径长度：路径上边的数目，简单路径：顶点不重复
- 距离：最短路径的长度
- 环/回路：n个顶点，大于n-1条边，必有环（只无向图？？？）
## 物理存储（设结点数 n 边数 e）
- 邻接矩阵
  - 表示唯一，多用于存稠密图，顺序存储，n*n 矩阵，如二维数组，空间O(n^2)
  - A[i][j] = 1 or 权值，为点i到点j有边；0 or ∞，为无边
- 邻接表
  - 表示可能不同，多用于存稀疏图，链接存储，空间无向O(n+2e)，空间有向O(n+e)
  - 为每个顶点Vi建立一个单链表，而头指针+顶点们的信息存于顶点表（顺序表）H[]
  - 即 顶点表结点 = 顶点域 + 边表头指针，边表结点 = 邻接点域 + 指针域
  ~~~
  顶点H[1] →顶点1的第一条边连向的顶点2|顶点1到顶点2的距离 →顶点1连的第二条边连向顶点4|顶点1到顶点4的距离...
  顶点H[2] →顶点2的第一条边连向顶点4|顶点2到顶点4的距离 →...
  顶点H[3] →...
  ~~~
- 十字链表
  - 有向图，链式存储，顶点结点顺序存储
  - 弧结点：info域，headvex头域指示弧头顶点位置，tailvex尾域指示弧尾顶点位置，hlink指针指向弧头相同的下一条弧，tlink指向弧尾相同的下一条弧
  - 顶点结点：data域，firstin指针指向以该顶点为弧头的第一个弧结点，firstout指针指向以该顶点为弧尾的第一个弧结点
- 邻接多重表
  - 无向图，链式存储，顶点结点顺序存储
  - 边表结点：info域，mark标志位该边是否被搜索过，ivex和jvex指示该边连的两顶点位置，ilink指向下一条依附于ivex的边，jlink指向jvex的
  - 顶点结点：data域，firstedge指示第一条依附于该顶点的边
## 遍历
- 广度优先 BFS Breadth-First-Search
  - 思路：先访问某起始顶点v，然后依次访v的未访过的邻接点们w1 w2...，然后依次访w1 w2 ...们的未访过的邻接点们，类推，直到访完
  - 由已知顶点出发，依次访问已知点的未访问过的邻接点
    - 类似层次遍历，用队列实现，借助辅助数组
    - 相同思想：Dijkstra 单源最短路径算法（按距离由近到远遍历）、Prim 最小生成树算法
  - 辅助：队列Q类似层次遍历地用来控制访问的结点，数组visit[i]标志顶点vi是否被访问过
  - 空间O(n)时（每个结点都要入队一次），邻接表矩阵O(n^2)，邻接表O(n+e)
- 深度优先 DFS Depth-First-Search
  - 思路：先访问（即输出）任意一个起始顶点v，然后去找v的任一未访邻接点w，再访w的任一未访x，以此类推，直到最深，随后退回到最近被访的顶点，找该点的其他未访邻接点
  - 从已知顶点出发，访问任一未访邻点，接着访问该未访邻点的任一未访邻点，以此类推到底，再退回上一个找
    - 类似先序遍历，可递归实现，非递归用栈实现
    - 递归函数 DFS(Graph G, int v)：先访问标记并输出本结点v，再找v的未访邻接点、找到进入下一层DFS递归，找不到则退出本层
    - 判断回路：一次访问完all点？
  - 空间O(n)时，邻接表矩阵O(n^2)，邻接表O(n+e)
- 连通性：遍历图来判断，一次遍历即能访到所有点即为连通or强连通
## 应用
- 最小生成树 MST Minimum-Spanning-Tree span-范围（Prime & Kruskal）
  - 是极小连通子图，树型不唯一，包含all顶点，边的权值之和最小，边数 = 顶点数 - 1 = n - 1
  - 利用性质：设G=(V,E)是一个带权连通无向图，U是结点集V的子集，(u,v)是一条最小权值的边，u∈U，v∈V-U，则必存在包含该边的MST
  - 基于贪心算法策略：每趟都找到当前局部最优解
  - 算法思路：T未形成一颗生成树时，找到一条最小代价边加入T且不产生回路，循环直到T成
  - 普利姆 Prim 算法：点集出发
    - 适用于稠密图，从顶点集开始分析，以顶点合并完为准，时间O(n^2)
    - 从已有点的集合出发，从通向还未合并的点的路径们中，找到权值最小的边、该边连着的点、加入不构成环的，访问且合并到已有点集，直到点都并完
    - 顺着来，从已有出发，在和已有点连着的边里，找 连着未连点的边 中的最小边，并入
  - 克鲁斯卡尔 Kruskal 算法：边集出发
    - 适用于稀疏图，用边连接两个顶点开始分析，以 边数 = n - 1 为准，时间O(e*loge)
    - 从未合并的边集和出发，从未合并的边中找权值最小的边，加入它后和已有树们不构成回路，则合并到已有边集，直到边=n-1
    - 乱序生成，只看哪条边最小，且加入不成环，并入
- 最短路径（Dijkstra & Floyd）
  - 点to点，路径权值min
  - 单源到各顶点最短：迪杰斯特拉 Dijkstra 单源最短路径算法
    - 时间O(n^2)，找源点to其他各点的路径和路径长度
    - 借助表寻找，横表头为第几趟寻找，纵表头为除源点的顶点列表，表内为该趟找到的、源点通向每个顶点的路径们
      - 每条路径都从源点开始，经过已有点的集合（已有点内构成的路径可能不止一条），分别找通向每个未合并的点 的路径们
      - 找到这些路径们中路径权值（即权值和）最小的路径、路径对应的未合并点，访问该点且合并到已有点集，记录路径长度，直到点都并完
    - 若有 权值＜0 的边，则可能无法得到正确结果
  - 任意两两顶点最短：弗洛伊德 Floyd 各顶点最短路径算法
    - 时间O(n^3)，找各个顶点互相之间的最短路径和路径长度，长度存在A(n-1)矩阵中
    - 构造n*n矩阵A寻找，迭代插点，方阵更替，变化矩阵内部内容，A(-1) A(0) A(1) ... A(n-1)
      - 初始A(-1)即该图的邻接矩阵，每迭代一次，从Vi到Vj的最短路径中多考虑一个顶点Vk，看和原路径比谁更短，k从0递增
      - A[i][j] = 点i到点j的 边权值 or 路径权值和，A(-1)初始化，A(k)[i][j] = min { A(k-1)[i][j], A(k-1)[i][k] + A(k-1)[k][j] }
    - 允许负权值边，不允许负权值边组成回路
- 拓扑排序
  - DAG图 有向无环图 Directed-Acyclic-Graph
    - 活动序列 = DAG的所有点输出的序列
  - AOV网 Activity-On-Vertex-Network
    - AOV网 = 顶点代表活动的DAG图，有向边表活动先后顺序，vertex-顶点，活动只能按顺序来
  - 拓扑排序：DAG图的all顶点组成的一个满足条件的序列，拓扑排序不唯一
    - 排出的顺序 = 边指向顺序，即 Vi→Vj，则排序Vi必在Vj前
    - 排序步骤：找无前驱的顶点为起点，输出之，再去掉该顶点和该顶点连的边们，找下一个顶点
    - 矩阵O(n^2+e)，表(n+e)，算法利用栈，入度=0则该顶点入栈，时间O(n+e)
- 关键路径
  - AOE网 Activity-On-Edge-Network
    - AOE网 = 带权有向？无环？图，顶点表示事件，边表示活动，权值表示活动开销，edge-边
    - AOE只有一个源点（入度=0），一个汇点（出度=0），中间全是过程的顶点
  - 性质（理解关键路径的基础）
    - 只有事件发生后，该事件后的活动才能开始；只有事件前的 all活动 都完成后，该事件才能开始
  - 关键路径：从源点到汇点的all路径中，具有最大权值（即最大路径长度）的路径。关键路径上的活动为关键活动，关键路径的开销 = 完成整个工程的最短时间
  - 找关键活动
    - 顶点 = 事件，边 = 活动，事件Vi to 事件Vj，中间经过 活动K
    - 事件最早发生 = max { 直接前驱事件最早 + 活动持续 }
    - 事件最迟发生 = min { 直接后继事件最迟 - 活动持续 }
    - 活动最早开始 = 活动起点的事件的最早发生时间
    - 活动最迟开始 = 活动终点的事件的最迟发生时间 - 活动时间
    - 关键活动条件：活动最早 = 活动最迟，即活动只能在一个时间开始
  - 桥：
  - 关键路径上提高效率，才可能提升整体效率

# 六、查找
- 查找表：用于查找的数据集合
  - 静态查找：不插入不删除不修改查找表
  - 动态查找：需要动态地插入or删除
- 静态适合：顺序，折半，散列
- 动态适合：散列，二叉排序树，二叉平衡，B树
- 平均查找长度 ASL Average-Search-Length
  - ASL = ∑Pi ·Ci = 所有可能过程中，关键字比较次数的平均值
  - 设 n = 表长，Pi = 找第i个元素的概率-默认均值1/n，Ci = 找到第i个元素进行的比较次数
## 线性结构
- 顺序查找：逐个检索
  - 线性表：ASL成功 = (n+1)/2，ASL失败 = n + 1
  - 有序表：ASL成功 = (n+1)/2，ASL失败 = n/2 + n/(n+1)
- 折半/二分查找：low，high，mid
  - mid = (low + high)/2，向上取整or向下取整都可用，但二选一选定后，在整个查找过程中不能变
  - 左边新high = mid - 1，右边新low = mid + 1
  - 过程
    - 折半查找判定树（是一棵二叉排序树，平衡吗？？但二叉排序树不都能当判定树）
    - 该树每层的结点，都是查找过程中生成的mid，符合同一个“取整规则”，17年8题
  - 时O(log(2)n)，只用于有序顺序表
  - ASL成功 = (n+1)/n ·log(2)(n+1) ≈log(2)(n+1) - 1
- 分块查找：索引+顺序
  - ASL成功 = ASL索引 + ASL块内
  - 索引元素需有序，查找方法不定；块内元素可无序，按顺序查找
## 树查找
- 二叉排序树
- 二叉平衡树
- B树
  - 本质：平衡因子为0的多路平衡查找树（即每颗子树一样高！）
  - m 阶：该树内允许的最大孩子结点数的值（即每个结点下最多m颗子树！）
    - 根结点：非终端则 子树棵数p 范围 2 ≤p ≤ m，关键字个数k 范围 1 ≤k ≤(m-1)
    - 非叶结点 下的 子树棵数p 范围 m/2 ≤p ≤m，也即最多 m 棵子树，除根结点外最少(m/2)向上取整棵子树
    - 非叶结点 内的 关键字个数k 范围 (m/2-1) ≤k ≤(m-1)，也即最多 m-1 个、最少 (m/2)向上取整再减一 个关键字
  - 非叶结点结构：{ n | P0 | K1 P1 | K2 P2 |...| Kn Pn}，“|”为自己的划分记忆方式
    - 分区记忆：｛关键字数n + 指针P0 + ∑结点Ki 指针Pi｝
    - n = 该结点中关键字的个数，Ki = 为关键字（左小右大），Pi = 指针指向儿子（该结点内共有 n+1 个指针）
    - 限定条件：根结点和非叶结点的关键字个数，子树个数的限定范围
  - 设一棵m阶B树的高为h，总共有n个关键字，则有关系式 log(m)(n+1) ≤ h ≤ log(m/2)((n+1)/2) + 1
  - 查找
    - 两个基本操作：在B树中找结点（磁盘操作）& 在结点内找关键字（内存操作）
    - 查找时，非叶节点、叶节点 均可包含数据，底层的单个叶结点们不含数据，so当前所说B树的高不包含最底下不带任何信息的叶结点
  - 增删：需保证操作后的结点关键字依然符合B树要求，如果破坏B树被操作结点的最大最小值，则需变化
  - 插入（涉及分裂，目标是使 k≤m-1）
    - 每次均插入终端结点（最底层的非叶结点），若插入后溢出（结点关键字个数k＞m-1），则需要从结点中间进行分裂
    - 分裂：原结点划分为三部分｛左边，中间结点ki，右边｝，ki ≥m/2，左边、右边分别成为新结点，ki向上并入父结点，最后再检查父结点是否溢出，溢出则再分裂
  - 删除（涉及合并，目标是使 k≥m/2-1）
    - 非终端结点（被删关键字kj）
      - 非叶结点の关键字两边存在前趋or后继、存在子树，删后先兄弟补位，否则孩子合并（被删除的结点k有左右子树）
      - 前趋后继补位：选择顺序从左到右，kj左子树关键字个数够多，则将左子树max关键字取上来补k的位置，左子树已经最小值了就看右子树找min关键字
      - 孩子合并：左右子树关键字数都已最小，不可再少，则将左右子树合并为一棵子树
    - 终端结点
      - 直接删除后若不满足 k≥m/2-1，则兄弟够借，否则双亲补位
      - 兄弟够借：左右兄弟都可，先把该兄弟和ki共同的父关键字取下来补ki的位置，再把该兄弟离k近的关键字推上去补父位，即父子顺移，挨个按大小关系往删的地方挪位
      - 兄弟不够借，双亲补位：左右兄弟关键字数都已最小，则将k的父关键字取下来补ki位，此时被借关键字的两孩子处在同一侧，so两孩子要合并成一个，即 补位的要和原先k的一个同父兄弟，合并为一个结点
      - 双亲也不够：找双亲的双亲借关键字，把双亲补充到够借，回到“双亲补位”阶段，完成后折回来看双亲的双亲，被借的祖宗的两孩子此时也处在同一侧，需要合并成一个
  - 常用：文件在内存、磁盘的分层查找
- B+树
  - m 阶：每个结点内最多 m 个关键字
    - ！结点关键字个数 = 该结点子树个数 ！！
    - 根结点：非终端则 子树棵数p 范围 1 ≤p ≤ m，关键字个数k 范围 1 ≤k ≤m
    - 非叶结点 下的 子树棵数p 范围 m/2 ≤p ≤m
    - 非叶结点 内的 关键字个数k 范围 m/2 ≤k ≤m
  - 非叶节点 = 索引作用，常用于数据库，限定条件，与B树的区别
  - 叶节点包含数据，非叶节点仅为索引，非叶节点关键字 = 其对应子结点关键字的最大值
- 红黑树
## 散列表（Hash表）
- 散列、杂凑，或音译为哈希
  - 通过散列算法（散列函数），把任意长度的输入变换成固定长度的输出
  - 根据关键码值 key value 直接进行访问 的数据结构
- 适用情况：直接映射，效率高；数据量多，需要快速查找定位
- 散列函数 Hash(key)：Address = Hash(key) = H(key)
  - 关键字key对应的存放地址Addr，由key通过一些方法映射而来
  - Addr =｛数组下标、索引、内存地址……｝
  - 冲突：Hash(key1) = Hash(key2)=... 两个或以上关键字映射到同一地址
  - 同义词：key1 key2 发生碰撞的不同关键字，为一组同义词
- 散列表：一种数据结构，根据关键字直接进行访问
- 查找性能理想情况O(1)，查找效率 = 装填因子 + 散列函数 + 处理冲突方法
  - ASL 取决于 装填因子α，α= 表中记录数n/散列表长m，α↑则记录多容易冲突
- 散列函数构造、构建哈希表
  - 直接定址法：H(key) = a*key + b，常用
    - 关键字的线性函数，适合分布基本连续的关键字，无冲突，易空间浪费
  - 除留余数法：H(key) = key % p = key mod p，常用
    - 关键字个数 = m，p一般选择≤m的最大质数
  - 平方取中法：H(key) = key^2的中间几位
    - 具体几位看情况，适合关键字每一位都不够均匀or均小于散列地址所需位数
  - 数字分析法：H(key) = 数码分部均匀的若干位？？？
    - 适合已知的关键字合集
  - 折叠法：H(key) = 关键字分割成的位数相同的几部分的叠加和
    - 适合关键字位数多，每一位上数字分布均匀
  - 伪随机法？？
### 解决冲突：开放定址法，拉链法
- 开放定址法
  - 公式：Hi = ( H(key) + di ) % m
    - Hi = 发生冲突后第i次探测的Addr，di = Δ增量序列，m = 关键字个数，i = 1,2,...,k(k≤m-1)
    - 允许同义词标中的地址和正常计算的非同义词地址发生冲突，可存放新表项的空闲地址向同义词+非同义词开放
    - 其实就是
  - 线性探测：di = 1，2，…，m-1
    - 从冲突地址开始，顺序地查找该表中的下一个空单元；当查到m-1时，下一个是表首地址0（∵公式是mod）
  - 平方探测/二次探测：di = 1^2，-1^2，2^2，-2^2，…，k^2，-k^2
    - k≤m/2，m为质数且m可表示为4k+3。此m是表长否？？？k是di里的k否？？？
    - 避免“堆积”问题，不能探测散列表所有单元，至少可以探测一半
    - 从冲突地址开始，按平方序列增加？？地查找该表中的空单元，注意mod m
  - 再散列/双散列法：di = Hash2(key)
    - 最多 m-1 次可遍历表中所有位置，回到H0位置
  - 伪随机序列法：di = 伪随机数序列
  - 建立公共溢出区？？？
  - 堆积问题：同义词冲突的探查序列，和非同义词之间不同的探查序列，交织→关键字查询需要较长的探测距离，降低散列的效率。？？
  - 不可随便物理删除表中的已有元素，会截断其他冲突元素的查找地址
- 拉链法/链地址法
  - 一组同义词存储于一个线性链表，用这组同义词的共同散列地址对该链表进行唯一标识
  - 避免同义词和非同义词冲突，适合经常插入、删除的情况，操作主要在同义词链中进行
    - eg：假设Addr=i的同义词链表头指针，存在散列表的第i个单元中。关键字序列key={10,23,32,55}，散列函H(key)=key%3，(表长=4)
    - 则通过H(key)分别得到散列地址1，2，2，1，假设Addr=数组下标，散列表为HH[4]，则HH[1]中存储同义词10、55的链表头指针，链表第一个元素为10，第二个为55
      HH[0]^
      HH[1]→10→55
      HH[2]→23→32
      HH[3]^
## 字符串模式匹配 KMP Knuth-Morris-Pratt Algorithm
- 串的模式匹配：求第一个字符串（模式串）在第二个字符串（主串）中的位置
- 主串指针不回溯，next数组，模式串的指针依据next数组滑动，避免无意义比较
- 改进 KMP，nextval数组


# 七、排序
- 大多适用于顺序存储的线性表，设表中有n个元素
- 稳定性：设数列中存在a[i]=a[j]，排序之后a[i]和a[j]的相对位置不变，则算法稳定
- 外部排序：排序时元素必须根据需求不断在内存、外存中移动，如多路归并
- 内部排序：排序时元素全在内存中，如下
## 插入
- 直接插入
  - 表L = {有序L[]，无序剩余L（Li是无序首部元素）}，有序L[l-(i-1)]
  - 顺序扫描，依次将待排序元素插入有序子表
  - Li和有序L[]进行比较，若当前元素L[i]＜L[i-1]，则顺序比较Li和Li之前的有序子表，找到位置将Li插入，插入位后的元素顺移腾空间后插入；否则扫描下一个
- 折半插入：比较当前元素和有序子表时，用折半查找确定元素位置，其余=直接插入
- 希尔排序（缩小增量排序）：分割若干子表L[i, i+d, i+2d, ...] ，i是否数组下标？？也叫缩小增量排序
  - 取一个小于n的整数k（通常取k≤n/2？？向下取整？）作为间隔，将全部元素分为k个子表？，所有距离为k的元素属于同一个子表
    - 注意：间隔为 n，则同一子序列的元素之间隔着(n-1)个数，eg：6 4 2 1 3，以3为间隔，则 6 1 为一个子序列，4 3 为一个子序列，剩 2 为一个子序列 
  - 子表内先排序（原版方法是直接插入排序）然后缩小间隔k，重复上述子表划分和排序
  - 最后取k=1，将所有元素放在同一个子表中排序
  - 步长d1时子表都有序后，取d2＜d1（通常dk=dk/2），再对d2时的子表们排序，直到di=1
## 交换
- 冒泡排序
  - 每一趟内两两比较相邻元素，逆序则交换，最多n-1趟排完
  - 从前往后扫描，一趟完后，最大的交换到了最后
  - 也可从后往前扫描，一趟完后，最小的交换到了最前
- 快速排序：平均性能最优，递归求解，L[]，low，high
  - 分治法：任取一个元素k为枢值（一般选当前子表的第一个元素），将表中小于k的放到k前，大于k的放到k后
  - 递归：表L进行一趟分治，分为左子表和右子表，枢值k；再将L左右子表分别分治，即产生递归
  - 跳出条件：已经不存在没分治过的子表，即 low == high
  - 一趟分治划分：输入要分治的表 L[]，表头位置 low，表尾位置 high
    - 比如 选第一个元素为枢值mid，，然后左右来回扫数和枢值比较，找到一个要换的数，和枢值换，之后改变扫描方向
    - 扫描枢值右边的元素，就找比枢值小的，交换；扫描枢值左边的元素，就找比枢值大的，交换
    - 思路和效果：小于枢值放左边、大于的从右开始放（即交换元素），最后返回枢值mid的位置
    - 枢值的选取理论上可以随机，如随机选，有利于提高快排效率
## 选择（不稳）
- 简单选择
  - 表L = {有序L[]，Li，无序剩余L}
  - 一趟找出一个无序子表L中最小的元素，将之与Li交换，作为第i个元素进入有序子表末尾
- 堆排序  ：将L[]看成一颗完全二叉树的顺序存储结构
  - 堆L[n]：L(i)≤L(2i)且L(i)≤L(2i+1)——小根堆，反过来即大根堆
  - 即 小根堆-根最小-双亲≤孩子，大根堆-根最大-双亲≥孩子，只要求父母和孩子关系，不要求孩子有序
  - 堆：一类特殊的树，特点是父结点一定大于or小于它所有的子结点，通常使用满足条件的完全二叉树以便于存储
  - 排序过程：调整 初始树 为 堆，即 将二叉树调整为有序完全二叉树
    - 如 6 1 5 9，初始二叉树6为根，左右孩子为15，5左孩子是9？？ 18年11题
    - 排序：从下往上，逐步调整，从最后一个 非叶子结点、从树底向树顶调整，如 大根堆，若当前父母小于子女，将父母和子女位置交换，再看下一个父母。每趟子树根结点位置 = i/2 - 1 的向下取整，初始 i = n
  - 用途：实现优先级队列
## 归并、基数
- 归并排序：将≥2个的有序表组合为一个新的有序表，将n个元素的待排序表看成n个有序子表
  - 排序操作：low＜high时，取mid划分表，递归进行排序
    - 将传入递归函数的表从中间划为两子表，后将两子表分别递归排序，后将已排序的两子表进行归并操作
  - 归并操作：归并函数内合并两个表，使用辅助数组正常排序
  - 一趟时间O(n)，共log₂n趟
  - 二路归并 = 两两归并
- 基数排序：多关键字，按关键字的每个数位排序
  - 如先按个位排序，然后再按十位排序，最后百位
  - 不需要元素间比较
## 以上为内部排序（常见9种）
算法      |稳定性|平均时O(n²)  |平均空O(1)  |备注
----------|------|--------------|------------|----
-**插入**-|------|--------------|------------|设表长 = n，时间√代表O(n²)，空间√代表O(1)
直接插入  |√    |√            |√
折半插入  |√    |√            |√
希尔排序  |不稳  |O(n^(1.3))    |√          |实际时间O依赖于增量函数
-**交换**-|------|--------------|------------
冒泡排序  |√    |√            |√          |一趟一个最终位置
快速排序  |不稳  |O(n * log₂n) |O(log₂n)栈 |一趟一个最终位置，最坏时间O(n²)，最坏空间O(n)
-**选择**-|------|--------------|------------
简单选择  |不稳  |√            |√          |一趟一个最终位置
堆排序    |不稳  |O(n * log₂n) |√          |一趟一个最终位置，有序完全二叉树
-**其他**-|------|--------------|------------
二路归并  |√    |O(n * log₂n) |O(n)        |多路归并则为外部排序？
基数排序  |√    |O[d(n+r)]     |O(r)队列    |d = 趟数

- “快些选堆”不稳定，即 快排，希尔，简选，堆

## 外部排序
- 排序文件较大，内存一次放不下，文件需存放在外部介质
- 核心耗时：I/O存取
- 核心问题：内存空间有限
- 多路平衡归并
  - 一整套解决方案
  - m路归并：减少I/O费时
  - 败者树：抵消m增多对比较次数的影响
  - 置换-选择：增大归并段长，生成不同长度段以减小趟数
  - 最佳归并树：m叉树，减少I/O访问次数，最短带权路径长度WPL
## 其他
- 睡眠排序
  - 根据CPU的调度算法实现——讲cup调度算法？？
  - 对一组数据进行排序，不能存在负数值，这个数是多大，那么就在线程里睡眠它的10倍再加10
  - 睡眠和它的数值不一样大的原因：当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果
  - 利用栈，醒一个入栈一个，出栈可得倒序结果

# 串


# 八、其他
## 筛子算法 Erat osthenes
最早计算素数个数的算法

