# 基本概念

## 数据结构
- 数据结构：
- 数据：
- 结构：
-
- 数据的逻辑结构：集合、线性、树、图
- 数据在计算机中的存储结构：顺序、链接、索引、散列
- 对数据进行各种非数值运算：查找、排序、插入、删除、修改、遍历

## 算法
- 算法：
- 特性：
-
- 不同逻辑结构 + 不同存储结构 + 不同运算方法 = 不同算法 = 不同运行时间&存储空间效率

- 时间复杂度O(n)
> O(1) < O(log2n) < O(n) < O(nlog2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

- 空间复杂度S(n)

# 线性表
- 基本操作
- 表示：顺序、链式
- 顺序表vs链表
-

## 顺序存储结构
- 顺序表示
-

## 链表
- 链式存储结构，链式表示
-
- 单链表
- 双链表
- 循环链表
- 静态链表
-


## 数组


# 队列 栈
- 栈：
- 队列：

## 应用
- 栈：括号匹配，表达式求值，递归
- 队列：层次遍历，计算机系统

## 特殊矩阵的压缩存储
- 矩阵的压缩存储
- 稀疏矩阵
-

# 树 二叉树
- 树
- 二叉树

## 二叉树
- 遍历
- 线索二叉树
- 二叉排序树
- 平衡二叉树
-

## 树 森林
- 遍历
- 并查集
- 哈弗曼树，哈弗曼编码，Huffman

# 图
## 存储操作
- 邻接矩阵
- 邻接表
- 十字链表
- 邻接多重表

## 遍历
- 广度优先 BFS Breadth-First-Search
- 深度优先 DFS Depth-First-Search
- 遍历
- 连通性

## 应用
- 最小生成树 MST Minimum-Spanning-Tree
- 最短路径
- 拓扑排序
- 关键路径

# 查找
## 顺序
- 顺序查找
- 二分/折半 查找
- 分块查找

## 树查找
- B树
- B+树
- 红黑树

## 散列表（Hash表）
- 散列（Hash）
- 关联数组是这样的数组，它的每个数据元素与一个键相对配对，该键用于识别数据元素。由于散列函数用来创建关联数组中的指定元素，并在关联数组中查找指定元素，因此关联数组通常称为散列
- 散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值
-
- 散列函数Hash(key)：Addr = Hash(key) = H(key)
  - 把查找表中的关键字映射为该关键字对应的存放地址Addr
  - Addr =｛数组下标、索引、内存地址……｝
- 冲突：Hash(key1) = Hash(key2)=...
  - 两个或以上关键字映射到同一地址
- 同义词：key1 key2 发生碰撞的不同关键字，为一组同义词
- 散列表：一种数据结构，根据关键字直接进行访问
- 查找和性能 理想情况O(1)
-
- 适用情况：数据量多，快速查找
-
### 散列函数构造方法
- 直接定址法：H(key) = a×key + b
  - 关键字的线性函数，适合分布基本连续的关键字，无冲突，易空间浪费
- 除留余数法：H(key) = key % p = key mod p
  - 关键字个数 = m，p一般选择≤m的最大质数
- 数字分析法：H(key) = 数码分部均匀的若干位？？？
  - 适合已知的关键字合集
- 平方取中法：H(key) = key^2的中间几位
  - 具体几位看情况，适合关键字每一位都不够均匀or均小于散列地址所需位数
- 折叠法：H(key) = 关键字分割成的位数相同的几部分的叠加和
- - 适合关键字位数多，每一位上数字分布均匀
- 随机数法：H(key) = ？？？
-
- 一直提到同步异步，下次讲一哈？不是具体某个语言的运用，是组成原理那种
-
### 解决冲突方法
#### 开放定址法
- 公式：Hi = ( H(key) + di ) % m
  - 允许同义词标中的地址和正常计算的非同义词地址发生冲突
  - 可存放新表项的空闲地址向同义词+非同义词开放
  - Hi = 发生冲突后第i次探测的Addr，di=增量序列
  - m=关键字个数，i=1,2,...,k(k≤m-1)
- 线性探测法：di = 1，2，…，m-1
  - 从冲突地址开始顺序查表中的下一个单元，当查到m-1时，下一个是表首地址0
- 平方探测法/二次探测：di = 1^2，-1^2，2^2，-2^2，…，k^2，-k^2
  - k≤m/2，m为质数且m可表示为4k+3。此m是表长否？？？k是di里的k否？？？
  - 避免“堆积”问题，不能探测散列表所有单元，至少可以探测一半
- 再散列法/双散列法：di = Hash2(key)
  - H(key)的地址冲突时，再用H2(key)算关键字地址增量
  - 最多m-1次可遍历表中所有位置，回到H0位置
- 伪随机序列法：di = 伪随机数序列
- 建立公共溢出区？？？
- 堆积问题：同义词冲突的探查序列，和非同义词之间不同的探查序列，交织，→关键字查询需要较长的探测距离，降低散列的效率。？？
- 不可随便物理删除表中的已有元素，会截断其他冲突元素的查找地址
-
#### 拉链法/链地址法
- 一组同义词存储于一个线性链表，这组同义词的散列地址对该链表进行唯一标识
- 避免同义词和非同义词冲突，适合经常插入、删除的情况，操作主要在同义词链中进行
  - eg：假设Addr=i的同义词链表头指针，存在散列表的第i个单元中。关键字序列key={10,23,32,55}，散列函H(key)=key%3，(表长=4)
  - 则通过H(key)分别得到散列地址1，2，2，1，假设Addr=数组下标，散列表为HH[4]，则HH[1]中存储同义词10、55的链表头指针，链表第一个元素为10，第二个为55
    HH[0]^
    HH[1]→10→55
    HH[2]→23→32
    HH[3]^
  - 还是加图吧……

## 字符串模式匹配
- 简单
- 改进 KMP

# 排序
- 二分
- 冒泡
- 
-

-
---

# 筛子算法 Erat osthenes
最早计算素数个数的算法



