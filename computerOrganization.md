# 相关其他
1 8 23
符号位 整数位 小数位
- float32、64存储方式 科学计数法表示 2^e
1 8 23
符号位 指数位 尾数位
特殊值：0.0 
指数、尾数位全0，表示0
指数全0 尾数全1？全1？非可读数
指数全1，尾数全0 表是无穷大
表示范围
编程语言内部规定 精度

- 32位浮点数
1      2-9    10-32
符号位 指数位 尾数位（数值位）
V = (-1)^s x M x 2^e
V = (-1)^s x M x 2^(e^-127)
符号位(-1)^s 

尾数 基数 指数 偏移量
符号位1位 e-8位 M-23位
S e M
7.00 = 3.5 x 2^1 = 1.75 x 2^2
https://www.cnblogs.com/icmzn/p/5060195.html

浮点数:
    其中:浮点数的第一位为符号位,2-9位属于指数位(以2为底,其中指数位称为阶码),后面的10-32为数值位(尾数位)(尾数位不仅决定了其精度,还决定了其所能取的数值范围)
    其中:double预留了11位来保存指数位,也就是说,double64一共有52的存储位(符号位一位),其精度是float的两倍左右.
    其中:浮点数的实际尾数位为24bit,而双精度的实际尾数位为53bit
    浮点数的存储原理:
            假设我们有100010这么个二进制的数,具体的科学计数法化后如下的表示
            100010=1.00010*2e5
            注意,二进制的科学计数法不是以10为底数.
            这么简单的解释下为何以2为底吧.
            同理,二进制移动一位则是乘除以2
        首先符号位存储符号,指数位存储科学计数中的指数,尾数位存储1.00010这部分
        我们现在有一个数8.25
        整数部分直接化为二进制:1000
        小数部分就可以化为01(小数转换原理:2e-1+2e-2+2e-3+.....2e-n)
        那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
        由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能分别表示24bit/54bit的数据
        那么,24位能精确到小数点后多少位呢?
        首先:9(一位小数最大的值0.9,如果我们要表示最大的一位小数,就需要表示到0.9)的二进制为1001,所以需要使用4bit来精确表示十进制的一位小数. 
        那么24位大概能表示6-7位
        而关于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
        其中指数的范围从00000000开始,到11111111结束
        注:指数位不使用符号位,而使用一个的方式来表示负数部分.
        浮点数的指数: 
            指数位记录了浮点数科学计数法化的指数
            上述提到,23bit的内存能存储24bit的数值.
            其原因是因科学计数法化后的数第一位总是1.
            将其忽略不计后,它的存储有效位就等于24bit.
            那么此处就出现了一个问题,0.0的二进制为0000.
            科学计数法化之后,第一位也是0,其就不符合我们忽略第一位的这种规则.
            如此,指数部分就存储了一些特殊值,其中有三个值需要指出
                如果指数部分是0,尾数部分也是0,这样子代表的就是(±)0这个数值
                如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
                32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分是0的话,这个数代表了±∞
                如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
                32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分不是0的话,这个数代表了NaN(not a number)
            上述提到,科学计数法化以后,第一位都是1.所以在实际表示的时候都会将其省略
            那么,1(十进制数)是怎么存储的呢?
                我们将1化为二进制的科学计数法则是1*2e0
                第一位是1,就将其忽略掉,不表示在尾数
                则指数部分为0->127(指数偏移+127)
                在计算其值的时候->
                指数=127-127=0
                尾数为省略的1+0.0000=1.0
                1.0的0次方=1
            那么,2(十进制数)是怎么存储的呢?
                我们将2化为二进制科学计数法化则是1.0*2e1
                指数为1->127
    IEEE规定了指数偏移
        IEEE规定了一个固定值2的e-1次方-1
        以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
        比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
        那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果误差问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....

小数是怎么表示在内存中的
首先有定点数和浮点数的两种概念

定点数:
    小数点的位置不用特定的表示出来,它是有一个约定的固定位置
    如果无需关心其正负性,那么符号为将用于表示数值,无符号数所能表示的数值与有符号数所能表示的数是一样的
    我们以32位的一个数值为例
    定点数的内存结构为,第1位为符号位,第2-9位为整数位,10-32位为浮点位
    假设我们有一个小数8.25
    那么0(符号位)1000(整数位)01(2^-2)=0.25
浮点数:
    它不会在意小数点的位置
    其中:浮点数的第一位为符号位,2-9为指数位(以2为底(指数位决定了其精度),其中指数位称为阶码),后面的10-32为数值位(尾数位)(数值位标识了其可存储的最大数值)
    其中:双精度浮点数在精度上比float翻倍,double预留了11位来保存指数位
    其中:浮点数的实际尾数位为24,而双精度的实际尾数位为54
    示例:
    我们现在有一个数8.25
    整数部分就可以化为二进制1000
    小数部分就可以化为01
    那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
    由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能表示24/54的数据
    那么,24位能精确到小数点后多少位呢?
    首先:9的二进制为1001,所以4bit能精确表示十进制的一位小数点,
    那么24位大概能表示6-7位
    那么,对于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
    其中指数从00000000(-127)开始,到11111111(+128)结束
    IEEE规定的是指数偏移
    IEEE规定了一个固定值2的e-1次方-1
    以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
    比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
    那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果出错问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....


# 基本概念
- 四代计算机：电子管 →晶体管 →中小集成电路+半导体存储器+分时操作系统 →大超大集成电路+微处理器
- 计算机系统 = 硬件系统 + 软件系统
  - 层次结构：微程序机器层 →传统机器语言层 →操作系统层 →汇编语言层 →高级语言层
    - 计算机组成原理：微程序机器层，传统机器语言层
  - 南北桥架构演变：？？
  - 冯诺依曼机-以运算器为中心，现代计算机-以存储器为中心
    - 冯诺依曼结构计算机
      - 存储程序原理：控制流 + 存储中心 + 程序驱动
      - 要点：数据 + 程序，不加区分，存放在存储器中
  - 摩尔定律：相同价格，每18个月，性能 & 可容纳晶体管数目，提升一倍
- 程序
  - 翻译程序
    - 编译程序：高级语言 →汇编语言or机器语言，生成目标程序
    - 解释程序：一次一句，高级语言翻译为目标机器代码，不生成目标程序，直接执行
  - 汇编程序：汇编语言 →机器语言
- 语言：机器（计算机唯一直接识别执行），汇编，高级
- 软件：系统软件（操作系统，数据库管理系统等），应用软件
## 五大硬件组成
- 存储器 M：主存（内存） + 辅存（外存）
  - 主存 = n 个存储单元，存储单元 = m 个存储元件，存储元件中存一位二进制代码0或1
  - 存储字 = 存储单元内的一串二进制代码
  - 存储字长 = 存储单元的位数 = 一个字节（8bit）or字节的偶数倍
  - 主存逻辑组成 = 地址寄存器 MAR + 数据寄存器 MDR + 时序控制逻辑 + 存储体
    - MAR 用于寻址，位数 = 存储单元个数
    - MDR 位数 = 存储字长位数
    - 注：MAR MDR 属于主存，但现代CPU中 MAR MDR Cache 都存于CPU内
  - 主存容量 = MAR位 * MDR位，如 64K x 32位
    - MAR 位数（16位） → 2^16 = 2^10 * 2^6 = 64K 个存储单元
    - MDR 位数（32位） → 32位 = 一个存储单元有32位
    - 一个地址可寻到一个存储单元，MAR*MDR自然就是存储器容量
- 运算器 CA-ALU-PSW
  - 完成：算术运算 + 逻辑运算
  - 核心：算术逻辑单元 ALU Arithmetic-and-Logical-Unit
  - 必备通用寄存器：累加器 ACC、乘商寄存器 MQ、操作数寄存器 X、程序状态寄存器 PSW（PSW不属通用寄存器？）
  - 其他通用寄存器：变址寄存器 IX、基址寄存器 BR 等
- 控制器 CC-PC-IR-CU
  - 控制器 = 程序计数器 PC + 指令寄存器 IR + 控制单元 CU
  - PC：存放将执行的指令地址，自动+1，形成下一条指令地址，直接连通 MAR
  - IR：存放当前执行的指令，从 MDR 中获得指令，IR分析指令，其操作码 OP 送到 CU，地址码 Ad 送到 MAR
  - 指令译码，控制电路
- 输入设备 I
- 输出设备 O
- 工作过程
  - 主存中装入程序+数据 →从程序起始地址开始 →通过首地址从存储器取第一条指令，译码执行完成，计算下一条指令地址 →通过新地址取出第二条指令并执行，重复此过程直到结束
  - 信息流程
    - 以取数指令为例，将指令地址码指示的存储单元中的操作数取出后，送到运算器的ACC中
    - 取指令：PC →MAR →M →MDR →IR
    - 分析指令：OP(IR) →CU
    - 执行指令：Ad(IR) →MAR →M →MDR →ACC
## 性能指标
- 机器字长：一次定点整数运算能处理的二进制数据位数
- 数据通路带宽：外部数据总线宽度 = 总线一次能并行传送的信息位数
- 主存容量：主存储器能存储信息的最大容量
- 运算速度
  - 吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期
  - 响应时间：发送请求到获得结果的时间 = CPU执行时间 + 等待时间
  - 主频：机器内部主时钟的频率
  - CPU时钟周期 = 1/主频，CPU中最小时间单位
  - CPI：执行一条指令所需的时钟周期数，Clock-cycle-Per-Instruction
  - CPU执行时间：运行一个程序的时间 = 指令条数 * CPI / 主频 = 总CPU时钟周期数/主频
  - MIPS：每秒执行x百万条指令
  - FLOPS：每秒执行x次浮点运算，MFLOPS：x百万次，GFLOPS：x十亿次，TFLOPS：x万亿次
- 机器字长，指令字长，存储字长
  - 机器字长：计算机能直接处理的二进制数据的位数 = 内部寄存器大小
  - 指令字长：一个指令字中包含二进制代码的位数 = n * 存储字长（一般）
  - 存储字长：一个存储单元存储二进制代码的长度 = n * 字节


# 数据表示、运算
- 不同进制表示
  - 二进制B，八进制O-三位二进制，十六进制H-四位二进制，x进制的基数 = x
    - X进制→十进制：按权值展开，乘以数码，再相加
    - 十进制→X进制：整数部分——除基取余，先余为低，后余为高；小数部分——乘基取整，先整为高，后整为低
  - 十进制D-十进制的二进制表示方法BCD码-余3-8421-2421？？
- 字符、字符串
  - ASCII码：7位二进制编码，128个字符 = {10个十进制数码，52个英文大写，52个英文小写，专用符号}
  - GB xxx：汉字编码
  - 字符串存储
    - 大端模式：主存字内从高位开始存储，如两字节abcd存为abcd
    - 小端模式：主存字内从低位开始存储，如两字节abcd存为badc
- 数据校验
  - 原理：在正确数据之间加入冗余数据，用于检验or纠错
  - 奇偶校验码：奇校验码合法数据的1的总数 = 奇数，偶校验码合法数据的1的总数 = 偶数
  - 海明码 = 多位奇偶校验码，分配多个奇偶校验组
    - 过程：？？
    - 发现两位纠正一位，发现一位纠正一位
  - CRC循环冗余校验
    - 原理：被除数 ÷除数 = 商 + 余数，(余数 + 商) * 除数 = 被除数，（二进制下）
    - 信息码左移R位后 = 被除数，生成多项式 = 除数，商不管，余数即为要拼接的R位校验码
    - N位编码：K位信息码拼接R位校验码，即 左移R位后的K + R位校验码，共 K + R 位
    - 检验：收到的N位信息÷生成多项式，整除即正确，有余数则将对应余数位为1的位置信息位取反即可
- 定点数：有符号数，无符号数unsigned
  - 有符号数：二进制的最高位为符号位，0正1负，
  - 有符号数的机器表示：原码，补码，反码，移码
    - 原码：机器数的最高位 = 符号位，其余位表示数的绝对值|X|，数的真值为X
    - 补码：正数 [X]补 = [X]原，负数 符号位不变，数值按位取反，末位加1
    - 反码：正数 [X]反 = [X]原，负数 符号位不变，数值按位取反
    - 移码：补码的符号位取反即是，只能表示整数
  - 有符定点数加减乘除法？？
- 浮点数：float，double
  - float：浮点数的规格化，IEEE 754标砖
  - 浮点数加减法，对阶-尾数求和-规格化
## 算术逻辑单元 ALU
- 门电路基本原理
  - MOS晶体管：中间为开关，决定两边是否导通
  - 逻辑门：与门-面包？？，非门-三角，或门-导弹，异或门-带尾翼导弹
- 加法器
  - 原理：半加器，全加器，加法器的溢出-针对有符号数，行波进位加法器-串行
  - 优化：串行加法器，并行加法器，组内串行组间并行加法器
- 减法器：在加法器的基础上实现
- 乘法器
  - 原理：
  - 优化核心：节约资源、周期，减少芯片面积
  - 寄存器的合并与位移 & 加法器的优化
    - 被乘数寄存器缩减一半，取消左移
    - 取消乘数寄存器，乘数初始置于乘积寄存器低一半位
    - 乘积寄存器增加右移功能，乘积初始置于其中高一半位，随着运算过程不断右移
    - 加法器缩减为一般位宽，乘积寄存器只有高四位参与运算
- 除法器
- 原理：
  - 优化核心：减少芯片面积
  - 寄存器的合并与位移的优化
    - 除数寄存器缩小一半，不移位
    - 取消商寄存器
    - 加法器缩减为一半位宽
    - 余数寄存器只有高一半位参与加减法运算
    - 余数寄存器支持左移右移
    - 商从右端逐位移入商寄存器
    - 运算结束时，商占余数寄存器的低一半位
- 逻辑运算：实现逻辑运算，多个逻辑门组合 + 多选器选择功能

# 存储系统
- 主存与CPU的连接
  - 连接扩展：字扩展，位扩展，字位同时扩展
  - 内容选择方式：线选法，译码片选法
  - 访问提速方式：双端口RAM配合多处理器，多体高位交叉存储，多体低位交叉存储
- 存储容量的表示差异
  - 内存；2^10为底
  - 硬盘等外存：1000为底
  - 数据传输率、时钟频率：1000为底
## 存储器分类
- 按内容易失性：易失性存储器-断电内容消失，非易失性存储器-断电内容还在-如BIOS芯片
- 内容的访问方式：串行访问存储器，随机存储器RAM，只读存储器ROM
- 半导体随机存储器 RAM R啥啥
  - 静态 SRAM Static？
    - SRAM构造，写入读出过程，写入的数据与BL线的电平相一致
    - 6个MOS晶体管元件，不需要刷新
  - 动态 DRAM
    - DRAM构造
    - 电容元件，需要刷新-集中/分散/异步刷新
    - SDRAM内存的访问过程：行选到列选延迟tRCD，列选到数据输出延迟周期数CL，行预充电的延迟tRP
    - 主存技术：总体以牺牲访存延迟为代价，努力提升访存带宽
      - 核心频率：内存颗粒的核心频率
      - 等效频率：接口频率，将周期取多位计算在内
      - 工作频率：不考虑周期取多位的本质频率
    - SDR与DDRx性能对比：DDR每个周期取多个数据-连续读取数据时间DDR＜SDR，其他时间延迟DDR＞SDR
- 只读存储器 ROM
  - MROM，FROM
  - 可读可写：EFROM，Flash
- 串行访问存储器
## 计算机存储层次结构
- cache →主存
  - 解决CPU访问主存速度低问题：cache
  - cache：数据高速缓冲技术，基于局部性原理-时间局部性/空间局部性
  - cache映射方式：直接映射，全相联映射，组相联映射
  - 多层cache：第一层-数据cache/指令cache，第二层，第三层
  - cache读写策略
    - 替换算法：随机替换，FIFO，LRU，NRU
    - 读写策略：全写法配合非写分配法，写回法配合写分配法
  - cache失效：义务失效，容量失效，冲突失效
- 主存 →辅存（硬盘）
  - 解决地址翻译访存速度慢：TLB快表
  - 解决主存容量不足：虚拟存储技术
  - 虚拟存储技术：页式虚拟存储，段式虚拟存储，段页式虚拟存储
    - 段页式虚拟存储：地址翻译，缺页中断的置换算法
    - 置换算法：OPT，FIFO，LRU，Clock（NRU）

# 指令系统
- 指令格式
  - 简单的计算机指令系统三大类型指令
    - 运算类
    - 传送类：eg存储器到寄存器/寄存器到IO
    - 控制类：eg暂停处理器/清除标志位
    - 转移类
  - 指令内容的性质：操作码，地址码
  - 指令内容的长度：定长指令，不定长指令
  - 指令地址的数量：零地址指令，单地址指令，多地址指令
- 寻址方式
  - 指令寻址：顺序寻址，跳跃寻址
  - 数据寻址：立即，直接，间接，寄存器直接，寄存器间接，条件，相对，基址，变址，堆栈
- 定长操作码
- 扩展操作码
## 指令系统的大类划分 CISC RISC
- CISC
  - 指令长度可变，指令形式复杂多变，多种访存方式，寄存器用的少，一般用微程序控制方式
  - 代表：x86指令系统
  - x86机器工作模式
    - 传统模式：实模式-从加电启动复位到OS运行之前；保护模式-OS和应用程序的运行；虚拟8086/V86模式-运行兼容8086程序
    - 长模式：64位模式，兼容模式
  - 8086的寄存器
    - 通用寄存器
    - 指令指针寄存器：取指令后自增，保留一个内存地址，指向当前需要取出的指令
    - 标志寄存器：状态标志，控制标志
    - 段寄存器：与其他寄存器联合生成存储器地址-代码段寄存器CS-数据段寄存器DS-附加段寄存器ES-堆栈段寄存器SS；8086物理地址生成过程？？
  - 8086特点
    - 对外：数据线 = 16，地址线 = 20
    - 物理地址 = 段加偏移
    - 存储器中保留两个专用区域：最低1kb-中断向量表区，最高16b-初始化程序区
  - x86指令分类例子
    - 传送指令：传送指令MOV，栈操作PUSH POP，LEA指令
    - 算术运算：ADD ADC INC，SUB SBB DEC，CMP
    - 逻辑运算、位移：NOT AND，SHL，SHR SAR
    - 转移指令：无条件转移JMP，条件转移
    - 处理器控制指令
    - 复杂x86指令：REP前缀-无条件重复；串操作指令-MOVSB字节串传送-方向取决于DF位~0低地址开始~1高地址开始
- RISC
  - 指令长度固定，指令形式少而简单，只有load/store访存，寄存器用的多，一般用硬布线控制方式，全部应用流水线，需要优秀编译器支持
  - 代表：MIPS指令系统
  - MIPS主要关注点：减少指令类型，降低指令复杂度
  - 基本格式
    - R 寄存器：rs-通常指定第一个源操作数所在的寄存器编号，rt-第二个源操作数所在寄存器编号，rd-目的操作数要放的寄存器编号
    - I 立即数：rs = R中rs，rt-目的操作数所在的寄存器编号，i-立即数
    - J 无条件转移
  - MIPS指令分类例子
  - 运算指令：add sub mul div，and or，sll srl，带u溢出时不报异常，带i操作中有立即数
  - 访存指令：lw sw
  - 分支指令：jr，beq，j

# 中央处理器 CPU
- 功能：指令控制，操作控制，时间控制，数据加工，中断处理
- 基本组成结构：控制器，运算器，寄存器
- mips中cpu执行指令：取指 →译码 →执行 →访存 →回写
- 单周期处理器
  - 总体设计步骤
    - 分析指令系统，得出对数据通路的需求
    - 为数据通路选择合适的逐渐
    - 连接组件建立数据通路
    - 分析每条指令的实现，以确定控制信号
    - 集成控制信号，形成完整的控制逻辑
  - 组成部件
    - 算术逻辑单元ALU，立即数扩展部件-零扩展+符号扩展，程序计数器PC，寄存器堆RegFile，存储器，多选器
## 流水线、冒险
- 指令流水线技术
  - 切分单周期处理器，之间添加流水线寄存器
  - 单挑指令的执行时间不变，指令吞吐率提高
  - 流水线的无限制加深 = 时钟的主频提升 ≠性能提升
- 超标量技术：多条并行工作的流水线结构
- 多核CPU
- 并行性
  - 时间并行性：主要是对现有硬件的切分，eg：单周期to标量流水线
  - 空间并行性：需要成倍增加硬件资源，eg：标量to招标量流水线
- 局部性
  - 时间局部性：最近访问的存储器单元（指令or数据）很快还会被访问，eg：SUM、循环指令
  - 空间局部性：正在被访问的存储单元**附近**的单元很快会被访问，eg：数组
- 流水线与冒险
  - 数据冒险：周期停顿，产生空泡；数据旁路
  - 结构冒险：周期停顿，产生空泡；将一周期的工作分为前半个周期写，后半个周期读；单独设置存储器、寄存器；指令cache和数据cache
  - 控制冒险
    - 周期停顿，产生空泡
    - 不同类型转移指令的影响：无条件直接转移-流水线不停，无条件间接-流水线停一周期，条件转移-流水线停一周期
    - 延迟转移技术：用转移指令延迟来安排无关指令执行位置
    - 分支预测，预取指令

# 总线
- 分类：片内总线，系统总线，通信总线
- 仲裁：集中式，分布式
  - 集中式：链式查询，计数器定时查询，独立请求
- 通信
  - 同步：统一时钟
  - 异步：握手 = ｛不互锁，半互锁，全互锁｝

# 输入/输出系统与中断
- I/O接口
  - 基本功能：数据缓冲，提供联络信息，信号与信息格式转换，设备选择，中断管理，可编程功能
  - 基本结构：数据输入寄存器，数据输出寄存器，状态寄存器，控制寄存器，中断控制寄存器
  - I/O端口编址
    - 和存储器统一编址：RISC如MIPS采用，指令功能齐全-直接处理IO端口内数据，简化内部结构，占用存储地址空间，指令长度、执行时间相对较长
    - 和存储器分开编址：CISC如x86采用，IO端口不占用存储器地址，IO指令编码短、执行速度快，地址码短、地址译码方便，层次清晰便于理解，功能较单一，独立的控制逻辑、内部结构复杂
- I/O方式
  - 无条件传送：如单片机控制小灯泡
  - 程序查询：工作流程？？，CPU与IO串行
  - 程序中断：工作流程？？，CPU与IO并行，但CPU频繁响应中断
  - DMA方式
    - DMA控制器：DMAC
    - DMAC主要配置参数-CPU设置：源地址初始值、传送时的地址增减方式，目的地址初始值、传送时的地址增减方式，待传送数据的长度
    - DMA工作方式流程？？，专有数据传输不经过CPU
  - 通道方式：专用处理器
- 外设？？
## 中断
- 中断向量表
  - 保存在存储器地址最低的一部分
  - 存储中断服务程序的入口地址 = 中断向量
  - 计算？？
  - 保护模式的中断操作
    - 描述符地址 = 类型号 + IDTR
    - 获得CS和EIP
    - CS和GDTR得到段基值
    - 段基值和DIP得到真正保护程序的入口地址
- 中断处理流程
  - 中断隐指令 = 硬件：关中断 →保存断点 →识别中断源
  - 中断服务程序 = 软件：保护现场 + 中断屏蔽字 →若有多重中断则开中断 →恢复现场并返回，通过IRET或IRETD(32)/IRETQ(64)指令实现中断返回
- 中断指令：INT n
- 中断分类：内、外
  - 内中断：除了3=单字节指令，其他都是双字节指令，只有1能被软件方式屏蔽
    - 4 溢出中断：溢出标志位 OF = 1 进入中断，用于检验的INTO指令通常安排在算术运算指令之后
    - 3 断点中断：设置断点，通常与单步中断配合使用；唯一单字节指令，为保证设置断点用INT 3替换原有指令时，不影响其他指令运行
    - 2 非屏蔽中断
    - 1 单步中断：用于错误调试，TF = 1 时进入单步工作方式，唯一能通过软件方式屏蔽的内中断
    - 0 除法错中断
  - 外中断：IF标志位控制是否屏蔽
- 利用中断功能的调用：利用寄存器传入参数
  - BIOS中断 1AH：读取、设置时钟
  - DOS中断 21H：屏幕输出字符
- 多重中断
- 中断屏蔽技术、中断判优：中断屏蔽字
