# 基本概念

# 数据表示、运算
## 数制、编码
- 二进制 十进制 十六进制 互转

## 定点数
1 8 23
符号位 整数位 小数位

## 浮点数
- float32、64存储方式
科学计数法表示 2^e
1 8 23
符号位 指数位 尾数位

特殊值：0.0 
指数、尾数位全0，表示0
指数全0 尾数全1？全1？非可读数
指数全1，尾数全0 表是无穷大
表示范围
编程语言内部规定 精度

- 32位浮点数
1      2-9    10-32
符号位 指数位 尾数位（数值位）
V = (-1)^s x M x 2^e
V = (-1)^s x M x 2^(e^-127)
符号位(-1)^s 

尾数 基数 指数 偏移量
符号位1位 e-8位 M-23位
S e M
7.00 = 3.5 x 2^1 = 1.75 x 2^2
https://www.cnblogs.com/icmzn/p/5060195.html

浮点数:
    其中:浮点数的第一位为符号位,2-9位属于指数位(以2为底,其中指数位称为阶码),后面的10-32为数值位(尾数位)(尾数位不仅决定了其精度,还决定了其所能取的数值范围)
    其中:double预留了11位来保存指数位,也就是说,double64一共有52的存储位(符号位一位),其精度是float的两倍左右.
    其中:浮点数的实际尾数位为24bit,而双精度的实际尾数位为53bit
    浮点数的存储原理:
            假设我们有100010这么个二进制的数,具体的科学计数法化后如下的表示
            100010=1.00010*2e5
            注意,二进制的科学计数法不是以10为底数.
            这么简单的解释下为何以2为底吧.
            同理,二进制移动一位则是乘除以2
        首先符号位存储符号,指数位存储科学计数中的指数,尾数位存储1.00010这部分
        我们现在有一个数8.25
        整数部分直接化为二进制:1000
        小数部分就可以化为01(小数转换原理:2e-1+2e-2+2e-3+.....2e-n)
        那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
        由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能分别表示24bit/54bit的数据
        那么,24位能精确到小数点后多少位呢?
        首先:9(一位小数最大的值0.9,如果我们要表示最大的一位小数,就需要表示到0.9)的二进制为1001,所以需要使用4bit来精确表示十进制的一位小数. 
        那么24位大概能表示6-7位
        而关于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
        其中指数的范围从00000000开始,到11111111结束
        注:指数位不使用符号位,而使用一个的方式来表示负数部分.
        浮点数的指数: 
            指数位记录了浮点数科学计数法化的指数
            上述提到,23bit的内存能存储24bit的数值.
            其原因是因科学计数法化后的数第一位总是1.
            将其忽略不计后,它的存储有效位就等于24bit.
            那么此处就出现了一个问题,0.0的二进制为0000.
            科学计数法化之后,第一位也是0,其就不符合我们忽略第一位的这种规则.
            如此,指数部分就存储了一些特殊值,其中有三个值需要指出
                如果指数部分是0,尾数部分也是0,这样子代表的就是(±)0这个数值
                如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
                32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分是0的话,这个数代表了±∞
                如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
                32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分不是0的话,这个数代表了NaN(not a number)
            上述提到,科学计数法化以后,第一位都是1.所以在实际表示的时候都会将其省略
            那么,1(十进制数)是怎么存储的呢?
                我们将1化为二进制的科学计数法则是1*2e0
                第一位是1,就将其忽略掉,不表示在尾数
                则指数部分为0->127(指数偏移+127)
                在计算其值的时候->
                指数=127-127=0
                尾数为省略的1+0.0000=1.0
                1.0的0次方=1
            那么,2(十进制数)是怎么存储的呢?
                我们将2化为二进制科学计数法化则是1.0*2e1
                指数为1->127
    IEEE规定了指数偏移
        IEEE规定了一个固定值2的e-1次方-1
        以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
        比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
        那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果误差问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....

小数是怎么表示在内存中的
首先有定点数和浮点数的两种概念

定点数:
    小数点的位置不用特定的表示出来,它是有一个约定的固定位置
    如果无需关心其正负性,那么符号为将用于表示数值,无符号数所能表示的数值与有符号数所能表示的数是一样的
    我们以32位的一个数值为例
    定点数的内存结构为,第1位为符号位,第2-9位为整数位,10-32位为浮点位
    假设我们有一个小数8.25
    那么0(符号位)1000(整数位)01(2^-2)=0.25
浮点数:
    它不会在意小数点的位置
    其中:浮点数的第一位为符号位,2-9为指数位(以2为底(指数位决定了其精度),其中指数位称为阶码),后面的10-32为数值位(尾数位)(数值位标识了其可存储的最大数值)
    其中:双精度浮点数在精度上比float翻倍,double预留了11位来保存指数位
    其中:浮点数的实际尾数位为24,而双精度的实际尾数位为54
    示例:
    我们现在有一个数8.25
    整数部分就可以化为二进制1000
    小数部分就可以化为01
    那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
    由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能表示24/54的数据
    那么,24位能精确到小数点后多少位呢?
    首先:9的二进制为1001,所以4bit能精确表示十进制的一位小数点,
    那么24位大概能表示6-7位
    那么,对于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
    其中指数从00000000(-127)开始,到11111111(+128)结束
    IEEE规定的是指数偏移
    IEEE规定了一个固定值2的e-1次方-1
    以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
    比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
    那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果出错问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....

## 算术逻辑单元 ALU

# 存储系统
## 存储器
- 层次结构
- 层次化
## 半导体随机存储器
- SRAM
- DRAM
## 主存储器、CPU、双RAM、多模块存储器
## 高速缓冲存储器 Cache
## 虚拟存储器

# 指令系统
- 定长操作码
- 扩展操作码
## 指令寻址
## CISC RISC

# 中央处理器 CPU
- 功能
- 结构
- 指令执行
## 数据通路
## 控制器
## 指令流水线

# 总线
- 分类，结构，性能
- 总线仲裁
- 操作
- 定时
- 标准

# 输入/输出系统
- 外设
- 接口
- 方式
