# 相关其他
1 8 23
符号位 整数位 小数位
- float32、64存储方式 科学计数法表示 2^e
1 8 23
符号位 指数位 尾数位
特殊值：0.0 
指数、尾数位全0，表示0
指数全0 尾数全1？全1？非可读数
指数全1，尾数全0 表是无穷大
表示范围
编程语言内部规定 精度

- 32位浮点数
1      2-9    10-32
符号位 指数位 尾数位（数值位）
V = (-1)^s x M x 2^e
V = (-1)^s x M x 2^(e^-127)
符号位(-1)^s 

尾数 基数 指数 偏移量
符号位1位 e-8位 M-23位
S e M
7.00 = 3.5 x 2^1 = 1.75 x 2^2
https://www.cnblogs.com/icmzn/p/5060195.html

浮点数:
    其中:浮点数的第一位为符号位,2-9位属于指数位(以2为底,其中指数位称为阶码),后面的10-32为数值位(尾数位)(尾数位不仅决定了其精度,还决定了其所能取的数值范围)
    其中:double预留了11位来保存指数位,也就是说,double64一共有52的存储位(符号位一位),其精度是float的两倍左右.
    其中:浮点数的实际尾数位为24bit,而双精度的实际尾数位为53bit
    浮点数的存储原理:
            假设我们有100010这么个二进制的数,具体的科学计数法化后如下的表示
            100010=1.00010*2e5
            注意,二进制的科学计数法不是以10为底数.
            这么简单的解释下为何以2为底吧.
            同理,二进制移动一位则是乘除以2
        首先符号位存储符号,指数位存储科学计数中的指数,尾数位存储1.00010这部分
        我们现在有一个数8.25
        整数部分直接化为二进制:1000
        小数部分就可以化为01(小数转换原理:2e-1+2e-2+2e-3+.....2e-n)
        那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
        由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能分别表示24bit/54bit的数据
        那么,24位能精确到小数点后多少位呢?
        首先:9(一位小数最大的值0.9,如果我们要表示最大的一位小数,就需要表示到0.9)的二进制为1001,所以需要使用4bit来精确表示十进制的一位小数. 
        那么24位大概能表示6-7位
        而关于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
        其中指数的范围从00000000开始,到11111111结束
        注:指数位不使用符号位,而使用一个的方式来表示负数部分.
        浮点数的指数: 
            指数位记录了浮点数科学计数法化的指数
            上述提到,23bit的内存能存储24bit的数值.
            其原因是因科学计数法化后的数第一位总是1.
            将其忽略不计后,它的存储有效位就等于24bit.
            那么此处就出现了一个问题,0.0的二进制为0000.
            科学计数法化之后,第一位也是0,其就不符合我们忽略第一位的这种规则.
            如此,指数部分就存储了一些特殊值,其中有三个值需要指出
                如果指数部分是0,尾数部分也是0,这样子代表的就是(±)0这个数值
                如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
                32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分是0的话,这个数代表了±∞
                如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
                32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分不是0的话,这个数代表了NaN(not a number)
            上述提到,科学计数法化以后,第一位都是1.所以在实际表示的时候都会将其省略
            那么,1(十进制数)是怎么存储的呢?
                我们将1化为二进制的科学计数法则是1*2e0
                第一位是1,就将其忽略掉,不表示在尾数
                则指数部分为0->127(指数偏移+127)
                在计算其值的时候->
                指数=127-127=0
                尾数为省略的1+0.0000=1.0
                1.0的0次方=1
            那么,2(十进制数)是怎么存储的呢?
                我们将2化为二进制科学计数法化则是1.0*2e1
                指数为1->127
    IEEE规定了指数偏移
        IEEE规定了一个固定值2的e-1次方-1
        以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
        比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
        那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果误差问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....

小数是怎么表示在内存中的
首先有定点数和浮点数的两种概念

定点数:
    小数点的位置不用特定的表示出来,它是有一个约定的固定位置
    如果无需关心其正负性,那么符号为将用于表示数值,无符号数所能表示的数值与有符号数所能表示的数是一样的
    我们以32位的一个数值为例
    定点数的内存结构为,第1位为符号位,第2-9位为整数位,10-32位为浮点位
    假设我们有一个小数8.25
    那么0(符号位)1000(整数位)01(2^-2)=0.25
浮点数:
    它不会在意小数点的位置
    其中:浮点数的第一位为符号位,2-9为指数位(以2为底(指数位决定了其精度),其中指数位称为阶码),后面的10-32为数值位(尾数位)(数值位标识了其可存储的最大数值)
    其中:双精度浮点数在精度上比float翻倍,double预留了11位来保存指数位
    其中:浮点数的实际尾数位为24,而双精度的实际尾数位为54
    示例:
    我们现在有一个数8.25
    整数部分就可以化为二进制1000
    小数部分就可以化为01
    那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
    由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能表示24/54的数据
    那么,24位能精确到小数点后多少位呢?
    首先:9的二进制为1001,所以4bit能精确表示十进制的一位小数点,
    那么24位大概能表示6-7位
    那么,对于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
    其中指数从00000000(-127)开始,到11111111(+128)结束
    IEEE规定的是指数偏移
    IEEE规定了一个固定值2的e-1次方-1
    以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
    比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
    那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果出错问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....


# 基本概念
- 四代计算机：电子管 →晶体管 →中小集成电路+半导体存储器+分时操作系统 →大超大集成电路+微处理器
- 层次结构
- 南北桥架构演变
- 摩尔定律：相同价格，每18个月，性能 & 可容纳晶体管数目，提升一倍
- 翻译程序
  - 编译程序：高级语言 →汇编语言or机器语言
  - 解释程序：一次一句，高级语言翻译为目标机器代码，直接执行
- 汇编程序：汇编语言 →机器语言
- 冯诺依曼结构计算机
  - 存储程序原理：控制流 + 存储中心 + 程序驱动
  - 要点：数据 + 程序，不加区分，存放在存储器中
- 基本组成
  - 五大硬件组成：运算器CA-ALU-PSW，控制器CC-PC-IR-CU，存储器M-主存辅存，输入设备I，输出设备O
  - 控制器CC：指令译码，控制电路，指令寄存器IR，程序计数器PC，MAR，MDR
- 软件：系统软件，应用软件，机器-汇编-高级语言
- 工作过程
- 性能指标
  - 吞吐量
  - 响应时间
  - CPU时钟周期
  - 主频
  - CPI
  - CPU执行时间
  - MIPS
  - MFLOPS
  - GFLOPS
  - TFLOPS

# 数据表示、运算
- 不同进制表示
  - 二进制B，八进制O-三位二进制，十六进制H-四位二进制
  - 十进制D-十进制的二进制表示方法BCD码-余3-8421-2421？？
- 数据校验：原理为在正确数据之间加入错误的数据
  - 奇偶校验码：奇校验码合法数据的1的总数 = 奇数，偶校验码合法数据的1的总数 = 偶数
  - 海明码=多位奇偶校验：公式？？，发现两位纠正一位，发现一位纠正一位
  - CRC循环冗余校验
- 定点数：有符号整数int，无符整unsigned int，short，long int
  - int：二进制最高位表示正负
  - 原码，补码-正数不变-负数按位取反-最低位+1，反码-正数不变-负数按位取反，移码-符号位与补码相反-其他同补码？？
  - 有符定点数加减乘除法？？
- 浮点数：float，double
  - float：浮点数的规格化，IEEE 754标砖
  - 浮点数加减法，对阶-尾数求和-规格化
## 算术逻辑单元 ALU
- 门电路基本原理
  - MOS晶体管：中间为开关，决定两边是否导通
  - 逻辑门：与门-面包？？，非门-三角，或门-导弹，异或门-带尾翼导弹
- 加法器
  - 原理：半加器，全加器，加法器的溢出-针对有符号数，行波进位加法器-串行
  - 优化：串行加法器，并行加法器，组内串行组间并行加法器
- 减法器：在加法器的基础上实现
- 乘法器
  - 原理：
  - 优化核心：节约资源、周期，减少芯片面积
  - 寄存器的合并与位移 & 加法器的优化
    - 被乘数寄存器缩减一半，取消左移
    - 取消乘数寄存器，乘数初始置于乘积寄存器低一半位
    - 乘积寄存器增加右移功能，乘积初始置于其中高一半位，随着运算过程不断右移
    - 加法器缩减为一般位宽，乘积寄存器只有高四位参与运算
- 除法器
- 原理：
  - 优化核心：减少芯片面积
  - 寄存器的合并与位移的优化
    - 除数寄存器缩小一半，不移位
    - 取消商寄存器
    - 加法器缩减为一半位宽
    - 余数寄存器只有高一半位参与加减法运算
    - 余数寄存器支持左移右移
    - 商从右端逐位移入商寄存器
    - 运算结束时，商占余数寄存器的低一半位
- 逻辑运算：实现逻辑运算，多个逻辑门组合 + 多选器选择功能

# 存储系统
- 主存与CPU的连接
  - 连接扩展：字扩展，位扩展，字位同时扩展
  - 内容选择方式：线选法，译码片选法
  - 访问提速方式：双端口RAM配合多处理器，多体高位交叉存储，多体低位交叉存储
## 存储器分类
- 按内容易失性：易失性存储器-断电内容消失，非易失性存储器-断电内容还在-如BIOS芯片
- 内容的访问方式：串行访问存储器，随机存储器RAM，只读存储器ROM
- 随机存储器 RAM
  - 静态 SRAM
  - 动态 DRAM
- 只读存储器 ROM

- 层次化
## 半导体随机存储器
- SRAM
- DRAM
## 主存储器、CPU、双RAM、多模块存储器
## 高速缓冲存储器 Cache
## 虚拟存储器

# 指令系统
- 定长操作码
- 扩展操作码
## 指令寻址
## CISC RISC

# 中央处理器 CPU
- 功能
- 结构
- 指令执行
## 数据通路
## 控制器
## 指令流水线

# 总线
- 分类，结构，性能
- 总线仲裁
- 操作
- 定时
- 标准

# 输入/输出系统
- 外设
- 接口
- 方式
