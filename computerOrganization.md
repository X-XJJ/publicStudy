# 相关其他
1 8 23
符号位 整数位 小数位
- float32、64存储方式 科学计数法表示 2^e
1 8 23
符号位 指数位 尾数位
特殊值：0.0 
指数、尾数位全0，表示0
指数全0 尾数全1？全1？非可读数
指数全1，尾数全0 表是无穷大
表示范围
编程语言内部规定 精度

- 32位浮点数
1      2-9    10-32
符号位 指数位 尾数位（数值位）
V = (-1)^s x M x 2^e
V = (-1)^s x M x 2^(e^-127)
符号位(-1)^s 

尾数 基数 指数 偏移量
符号位1位 e-8位 M-23位
S e M
7.00 = 3.5 x 2^1 = 1.75 x 2^2
https://www.cnblogs.com/icmzn/p/5060195.html

浮点数:
  其中:浮点数的第一位为符号位,2-9位属于指数位(以2为底,其中指数位称为阶码),后面的10-32为数值位(尾数位)(尾数位不仅决定了其精度,还决定了其所能取的数值范围)
  其中:double预留了11位来保存指数位,也就是说,double64一共有52的存储位(符号位一位),其精度是float的两倍左右.
  其中:浮点数的实际尾数位为24bit,而双精度的实际尾数位为53bit
  浮点数的存储原理:
          假设我们有100010这么个二进制的数,具体的科学计数法化后如下的表示
          100010=1.00010*2e5
          注意,二进制的科学计数法不是以10为底数.
          这么简单的解释下为何以2为底吧.
          同理,二进制移动一位则是乘除以2
      首先符号位存储符号,指数位存储科学计数中的指数,尾数位存储1.00010这部分
      我们现在有一个数8.25
      整数部分直接化为二进制:1000
      小数部分就可以化为01(小数转换原理:2e-1+2e-2+2e-3+.....2e-n)
      那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
      由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能分别表示24bit/54bit的数据
      那么,24位能精确到小数点后多少位呢?
      首先:9(一位小数最大的值0.9,如果我们要表示最大的一位小数,就需要表示到0.9)的二进制为1001,所以需要使用4bit来精确表示十进制的一位小数. 
      那么24位大概能表示6-7位
      而关于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
      其中指数的范围从00000000开始,到11111111结束
      注:指数位不使用符号位,而使用一个的方式来表示负数部分.
      浮点数的指数: 
          指数位记录了浮点数科学计数法化的指数
          上述提到,23bit的内存能存储24bit的数值.
          其原因是因科学计数法化后的数第一位总是1.
          将其忽略不计后,它的存储有效位就等于24bit.
          那么此处就出现了一个问题,0.0的二进制为0000.
          科学计数法化之后,第一位也是0,其就不符合我们忽略第一位的这种规则.
          如此,指数部分就存储了一些特殊值,其中有三个值需要指出
              如果指数部分是0,尾数部分也是0,这样子代表的就是(±)0这个数值
              如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
              32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分是0的话,这个数代表了±∞
              如果指数部分是2的e次方-1(e代表存储指数的内存大小的bit),
              32位的浮点数存储的指数位如果为11111111,并且尾数的小数部分不是0的话,这个数代表了NaN(not a number)
          上述提到,科学计数法化以后,第一位都是1.所以在实际表示的时候都会将其省略
          那么,1(十进制数)是怎么存储的呢?
              我们将1化为二进制的科学计数法则是1*2e0
              第一位是1,就将其忽略掉,不表示在尾数
              则指数部分为0->127(指数偏移+127)
              在计算其值的时候->
              指数=127-127=0
              尾数为省略的1+0.0000=1.0
              1.0的0次方=1
          那么,2(十进制数)是怎么存储的呢?
              我们将2化为二进制科学计数法化则是1.0*2e1
              指数为1->127
  IEEE规定了指数偏移
      IEEE规定了一个固定值2的e-1次方-1
      以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
      比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
      那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
  注:使用浮点数注意事项
      1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
      2.浮点数计算结果误差问题
      比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....

小数是怎么表示在内存中的
首先有定点数和浮点数的两种概念

定点数:
    小数点的位置不用特定的表示出来,它是有一个约定的固定位置
    如果无需关心其正负性,那么符号为将用于表示数值,无符号数所能表示的数值与有符号数所能表示的数是一样的
    我们以32位的一个数值为例
    定点数的内存结构为,第1位为符号位,第2-9位为整数位,10-32位为浮点位
    假设我们有一个小数8.25
    那么0(符号位)1000(整数位)01(2^-2)=0.25
浮点数:
    它不会在意小数点的位置
    其中:浮点数的第一位为符号位,2-9为指数位(以2为底(指数位决定了其精度),其中指数位称为阶码),后面的10-32为数值位(尾数位)(数值位标识了其可存储的最大数值)
    其中:双精度浮点数在精度上比float翻倍,double预留了11位来保存指数位
    其中:浮点数的实际尾数位为24,而双精度的实际尾数位为54
    示例:
    我们现在有一个数8.25
    整数部分就可以化为二进制1000
    小数部分就可以化为01
    那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
    由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能表示24/54的数据
    那么,24位能精确到小数点后多少位呢?
    首先:9的二进制为1001,所以4bit能精确表示十进制的一位小数点,
    那么24位大概能表示6-7位
    那么,对于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
    其中指数从00000000(-127)开始,到11111111(+128)结束
    IEEE规定的是指数偏移
    IEEE规定了一个固定值2的e-1次方-1
    以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
    比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
    那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果出错问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....


# 基本概念
- 四代计算机：电子管 →晶体管 →中小集成电路+半导体存储器+分时操作系统 →大超大集成电路+微处理器
- 计算机系统 = 硬件系统 + 软件系统
  - 层次结构：微程序机器层 →传统机器语言层 →操作系统层 →汇编语言层 →高级语言层
    - 计算机组成原理：微程序机器层，传统机器语言层
  - 南北桥架构演变：？？
  - 冯诺依曼机-以运算器为中心，现代计算机-以存储器为中心
    - 冯诺依曼结构计算机
      - 存储程序原理：控制流 + 存储中心 + 程序驱动
      - 要点：数据 + 程序，不加区分，存放在存储器中
  - 摩尔定律：相同价格，每18个月，性能 & 可容纳晶体管数目，提升一倍
- 程序
  - 翻译程序
    - 编译程序：高级语言 →汇编语言or机器语言，生成目标程序
    - 解释程序：一次一句，高级语言翻译为目标机器代码，不生成目标程序，直接执行
  - 汇编程序：汇编语言 →机器语言
- 语言：机器（计算机唯一直接识别执行），汇编，高级
- 软件：系统软件（操作系统，数据库管理系统等），应用软件
## 五大硬件组成
- 存储器 M：主存（内存） + 辅存（外存）
  - 主存 = n 个存储单元，存储单元 = m 个存储元件，存储元件中存一位二进制代码0或1
  - 存储字 = 存储单元内的一串二进制代码
  - 存储字长 = 存储单元的位数 = 一个字节（8bit）or字节的偶数倍
  - 主存逻辑组成 = 地址寄存器 MAR + 数据寄存器 MDR + 时序控制逻辑 + 存储体
    - MAR 用于寻址，位数 = 存储单元个数
    - MDR 位数 = 存储字长位数
    - 注：MAR MDR 属于主存，但现代CPU中 MAR MDR Cache 都存于CPU内
  - 主存容量 = MAR位 * MDR位，如 64K x 32位
    - MAR 位数（16位） → 2^16 = 2^10 * 2^6 = 64K 个存储单元
    - MDR 位数（32位） → 32位 = 一个存储单元有32位
    - 一个地址可寻到一个存储单元，MAR*MDR自然就是存储器容量
- 运算器 CA-ALU-PSW
  - 完成：算术运算 + 逻辑运算
  - 核心：算术逻辑单元 ALU Arithmetic-and-Logical-Unit
  - 必备通用寄存器：累加器 ACC、乘商寄存器 MQ、操作数寄存器 X、程序状态寄存器 PSW（PSW不属通用寄存器？）
  - 其他通用寄存器：变址寄存器 IX、基址寄存器 BR 等
- 控制器 CC-PC-IR-CU
  - 控制器 = 程序计数器 PC + 指令寄存器 IR + 控制单元 CU
  - PC：存放将执行的指令地址，自动+1，形成下一条指令地址，直接连通 MAR
  - IR：存放当前执行的指令，从 MDR 中获得指令，IR分析指令，其操作码 OP 送到 CU，地址码 Ad 送到 MAR
  - 指令译码，控制电路
- 输入设备 I
- 输出设备 O
- 工作过程
  - 主存中装入程序+数据 →从程序起始地址开始 →通过首地址从存储器取第一条指令，译码执行完成，计算下一条指令地址 →通过新地址取出第二条指令并执行，重复此过程直到结束
  - 信息流程
    - 以取数指令为例，将指令地址码指示的存储单元中的操作数取出后，送到运算器的ACC中
    - 取指令：PC →MAR →M →MDR →IR
    - 分析指令：OP(IR) →CU
    - 执行指令：Ad(IR) →MAR →M →MDR →ACC
## 性能指标
- 机器字长：一次定点整数运算能处理的二进制数据位数
- 数据通路带宽：外部数据总线宽度 = 总线一次能并行传送的信息位数
- 主存容量：主存储器能存储信息的最大容量
- 运算速度
  - 吞吐量：系统在单位时间内处理请求的数量，主要取决于主存的存取周期
  - 响应时间：发送请求到获得结果的时间 = CPU执行时间 + 等待时间
  - 主频：机器内部主时钟的频率
  - CPU时钟周期 = 1/主频，CPU中最小时间单位
  - CPI：执行一条指令所需的时钟周期数，Clock-cycle-Per-Instruction
  - CPU执行时间：运行一个程序的时间 = 指令条数 * CPI / 主频 = 总CPU时钟周期数/主频
  - MIPS：每秒执行x百万条指令
  - FLOPS：每秒执行x次浮点运算，MFLOPS：x百万次，GFLOPS：x十亿次，TFLOPS：x万亿次
- 机器字长，指令字长，存储字长
  - 机器字长：计算机能直接处理的二进制数据的位数 = 内部寄存器大小
  - 指令字长：一个指令字中包含二进制代码的位数 = n * 存储字长（一般）
  - 存储字长：一个存储单元存储二进制代码的长度 = n * 字节


# 数据表示、运算
- 不同进制表示
  - 二进制B，八进制O-三位二进制，十六进制H-四位二进制，x进制的基数 = x
    - X进制→十进制：按权值展开，乘以数码，再相加
    - 十进制→X进制：整数部分——除基取余，先余为低，后余为高；小数部分——乘基取整，先整为高，后整为低
  - 十进制D-十进制的二进制表示方法BCD码-余3-8421-2421？？
- 字符、字符串
  - ASCII码：7位二进制编码，128个字符 = {10个十进制数码，52个英文大写，52个英文小写，专用符号}
  - GB xxx：汉字编码
  - 字符串存储：字中字节的存储顺序不同，字的存储顺序相同
    - 大端模式：先存高位，正常逻辑顺序，主存字内从数据高位开始存储，如两字节abcd存在0x00和0x01中，00存ab，01存cd
    - 小端模式：先存低位，主存字内从数据低位开始存储，如两字节abcd存在0x00和0x01中，00存cd，01存ab
- 数据校验
  - 原理：在正确数据之间加入冗余数据，用于检验or纠错
  - 奇偶校验码：奇校验码合法数据的1的总数 = 奇数，偶校验码合法数据的1的总数 = 偶数
  - 海明码 = 多位奇偶校验码，分配多个奇偶校验组
    - 过程：？？
    - 发现两位纠正一位，发现一位纠正一位
  - CRC循环冗余校验
    - 原理：被除数 ÷除数 = 商 + 余数，(余数 + 商) * 除数 = 被除数，（二进制下）
    - 信息码左移R位后 = 被除数，生成多项式 = 除数，商不管，余数即为要拼接的R位校验码
    - N位编码：K位信息码拼接R位校验码，即 左移R位后的K + R位校验码，共 K + R 位
    - 检验：收到的N位信息÷生成多项式，整除即正确，有余数则将对应余数位为1的位置信息位取反即可
- 定点数：有符号数，无符号数unsigned
  - 有符号数：二进制的最高位为符号位，0正1负，
  - 有符号数的机器表示：原码，补码，反码，移码
    - 原码：机器数的最高位 = 符号位，其余位表示数的绝对值|X|，数的真值为X
    - 补码：正数 [X]补 = [X]原，负数 符号位不变，数值按位取反，末位加1
    - 反码：正数 [X]反 = [X]原，负数 符号位不变，数值按位取反
    - 移码：补码的符号位取反即是，移码只能表示整数
  - 有符定点数加减乘除法？？
  - 补码定点数加减：符号位按逢二进一运算规则参与运算，符号位的进位舍去，得到的结果也是补码
- 浮点数：float，double
  - 表示格式：N = r^E * M
    - E 阶码，M 尾数，r 阶码的底，N 浮点数
  - float 浮点数的规格化，IEEE 754标准
    - 格式：数符m 阶码E 尾数M
      - 阶码用移码表示，尾数用原码表示
    - 左规格：结果非规格化时，尾数算术左移1位，阶码减1
    - 右规格：结果尾数溢出时，尾数算术右移1位，阶码加1
  - 浮点数加减法
    - 步骤：对阶，尾数求和，规格化
- 强制类型转换：结果保持位值不变，只是改变了解释这些位的方式
- 各编码方式和数值范围（略，见章末疑难总结）
## 算术逻辑单元 ALU
- ALU属于运算器，控制器决定运算器的操作和操作种类，数据来自存储器，处理结果送回存储器or暂存于运算器
- 基本功能：加减乘除，与或非，异或，移位，求补，等等
- 门电路基本原理
  - MOS晶体管：中间为开关，决定两边是否导通
  - 逻辑门：与门-面包？？，非门-三角，或门-导弹，异或门-带尾翼导弹
- 加法器
  - 原理：半加器，全加器，加法器的溢出-针对有符号数，行波进位加法器-串行
  - 优化：串行加法器，并行加法器，组内串行组间并行加法器
- 减法器：在加法器的基础上实现
- 乘法器：原理？
  - 优化核心：节约资源、周期，减少芯片面积
  - 寄存器的合并与位移 & 加法器的优化
    - 被乘数寄存器缩减一半，取消左移
    - 取消乘数寄存器，乘数初始置于乘积寄存器低一半位
    - 乘积寄存器增加右移功能，乘积初始置于其中高一半位，随着运算过程不断右移
    - 加法器缩减为一般位宽，乘积寄存器只有高四位参与运算
- 除法器：原理？
  - 优化核心：减少芯片面积
  - 寄存器的合并与位移的优化
    - 除数寄存器缩小一半，不移位
    - 取消商寄存器
    - 加法器缩减为一半位宽
    - 余数寄存器只有高一半位参与加减法运算
    - 余数寄存器支持左移右移
    - 商从右端逐位移入商寄存器
    - 运算结束时，商占余数寄存器的低一半位
- 逻辑运算：实现逻辑运算，多个逻辑门组合 + 多选器选择功能

# 存储系统（结合OS-内存管理）
- 存储器的性能指标：存储容量，存储速度，单位成本
  - 存储容量 = 字数 ×字长，如 1M ×8位
  - 存储速度：数据传输率 = 数据宽度/存储周期
  - 单位成本：每位价格 = 总成本/总容量
  - 存储时间 = 启动存取到完成存取操作的时间
  - 存取周期 = 读写周期 = 访问周期 = 存取时间 + 等待下次存取的时间 = 两次独立操作之间所需最小时间间隔
  - 主存带宽 = 数据传输率 = 单位时间（通常按秒）从主存进出信息的最大数量
    - 字/秒or字节/秒or位/秒，即 主存的速率，主存带宽 = 时间内存取的数据量 / 系统平均访问时间 ？？——王道视频19计组《局部性原理及其性能分析》
    - 系统平均访问时间 = Cache命中时访问时间 × 命中率 + 不命中时访问时间 × 失效率（即 1 - 命中率）
- 存储容量的表示差异
  - 系统效率e = Cache存取周期 ÷系统平均访问时间，表示 增加Cache后的存储器的性能 与 Cache本身的性能 的接近程度？？
  - 内存；2^10为底
  - 硬盘等外存：1000为底
  - 数据传输率、时钟频率：1000为底
## 存储器分类
- 按作用层次
  - 主存（内存），辅存（外存），高速缓冲存储器（Cache）
- 按介质
  - 磁表面存储器（磁盘，磁带），磁芯存储器半导体存储器（MOS型，双极型），光存储器（光盘）
- 按内容访问/存取方式
  - 随机存储器（RAM），只读存储器（ROM），串行访问存储器（顺序存取-磁带，直接存取-磁盘）
- 按内容的易失性
  - 易失性-断电内容消失（RAM），非易失性-断电内容还在（ROM，BIOS芯片，磁表面存储器，光存储器）
### 半导体随机存储器 RAM
- 易失性，可读可写
- 基本结构
  - 存储矩阵：大量相同的位存储单元阵列
  - 译码驱动：翻译来自地址总线的地址信号为对应存储单元的选通信号
  - 读写电路：完成读/写操作
  - 读/写控制线：控制芯片操作
  - 片选线：控制选中哪个存储芯片
  - 地址线：单向输入
  - 数据线：双向传输
- 74138译码器
- SRAM 静态RAM：多用于实现Cache
  - 存储元：双稳态触发器，6个MOS晶体管元件，不需要刷新
  - 写入读出过程，写入的数据与BL线的电平相一致
- DRAM 动态RAM：多用于实现主存
  - 栅极电容电荷存储信息，不断电信息也会消失，需要周期刷新
  - 电容元件，需要刷新-集中/分散/异步刷新
  - SDRAM内存的访问过程：行选到列选延迟tRCD，列选到数据输出延迟周期数CL，行预充电的延迟tRP
  - 主存技术：总体以牺牲访存延迟为代价，努力提升访存带宽
    - 核心频率：内存颗粒的核心频率
    - 等效频率：接口频率，将周期取多位计算在内
    - 工作频率：不考虑周期取多位的本质频率
  - SDR与DDRx性能对比：DDR每个周期取多个数据-连续读取数据时间DDR＜SDR，其他时间延迟DDR＞SDR
- 提速方案
  - 双端口RAM：一个存储器有左右两个独立的端口，允许两个独立控制器同时异步地访问存储单元
  - 多模块存储器
    - 单体多字：存储器中只有一个存储体，每个存储单元存储m个字，总线宽度 = m
    - 多体并行：高位交叉编址，低位交叉编址
### 只读随机存储器 ROM
- 非易失性，只供读出
- 分类
  - MROM 掩膜式只读存储器
  - PROM 一次可编程只读存储器
  - EPROM 可擦除可编程只读存储器
  - Flash Memory 闪速存储器
  - Solid State Drives 固态硬盘SSD
  - FROM 
- 可读可写：EFROM，Flash
## 计算机存储层次结构
- 多级存储系统：CPU →寄存器 →Cache →主存 →磁盘 →磁带、光盘
- 主存与CPU的连接
  - CPU通过数据总线、地址总线、控制总线和主存连接，涉及存储芯片，地址线，数据线，读写命令线，片选线
  - 主存容量的连接扩展
    - 字扩展，即增加主存中字的数量
    - 位扩展，即增加主存存储字长，使主存数据位数 = CPU数据线数
    - 字位同时扩展，如8片16K×4位RAM芯片，组成64K×8位存储器，两片为一组16K×8位（位扩展），4组构成64x8位（字扩展）
  - 内容选择：片选——CPU选择主存的存储芯片，字选——片选后再为芯片按地址码选存储单元，N条低位地址线完成
  - 片选的方式
    - 线选法：用除片内寻址（字选）外的高位地址线，直接分别接到各个存储芯片的片选端
    - 译码片选法：用除片内寻址（字选）外的高位地址线，通过地址译码器产生片选信号
  - 访问提速方式：双端口RAM配合多处理器，多体高位交叉存储，多体低位交叉存储
### Cache-主存层
- CPU、Cache、主存，三者之间可以两两双向直接访问
- Cache：数据高速缓冲技术
  - 解决CPU与主存之间传输速度低的问题，用于保存主存中最活跃的若干个块的副本
  - 基于局部性原理：时间局部性 or 空间局部性
- Cache命中率 = Cache命中次数 ÷访问总次数，访问总次数 = Cache命中次数 + 未命中时访问主存次数，失效率 = 1 - 命中率
- 采用Cache后，CUP访存的两种方式，不妨设Cache存取周期为t，主存存取周期为5t
  - Cache和主存同时访问：命中访问时间 = t，不命中访问时间 = 5t
  - 先访问Cache，不命中后再访问主存：命中访问时间 = t，不命中访问时间 = 6t
  - 系统平均访问时间 = 命中时间 × 命中率 + 不命中时间 × 失效率
  - 不命中时，CUP去主存取到所需数据块后，会同时将块放入Cache
- 存储器的系统？？？
- Cache块 = Cache行，是主存与Cache之间数据交换的基本单位
  - 每块都能划分出标记项（有效位+标记位）表明该块来自主存中的哪个块
  - Cache行的存储容量：{ 有效位 | 标记位 | 每行存储的数据位 }
  - 计算标记字段长度，如 P120
- Cache地址映射：将主存的一块 映射（复制）到 Cache的哪一块上 的问题
  - 理解：如 先按字节编址（如 容量为32B，则每个字节地址为从0~31编号，写成二进制则是5位地址 00000~11111），再人为分块（如 Cache中4B为一块，则总共5块，块号为0~4（000~011），第一块含的地址为0~3，4~7第二块……，字块内地址都为 00~11），主存和Cache均按此规则划分编址，之后 再人为将二进制地址分割成不同的部分，由于二进制表示，所以能够对二进制地址位进行分割拆分，如 前log5=3（向上取整）位刚好是行号，后log4=2位是块内地址，主存地址同理划分，会增加分割的地址用来标识该块在Cache的哪里，便于设计使用计算 ？？
  - 全相联映射
    - 主存地址划分结构：{ 主存字块标记 | 字块内地址 }
    - 主存数据块可装入Cache中的任意位置块中
    - 按内容寻址，使用相联存储器进行地址映射，成本高
  - 组相联映射：j = i mod Q
    - 主存地址划分结构：{ 主存字块标记 | 组地址 | 字块内地址 }
    - j Cache组号，i 主存块号，Q Cache组数
    - Cache分为大小相同的多个组，一个主存数据块可以装到固定组内的任意位置块中，组号由 主存块号 mod 组数 得出
    - 说法：n路组相联 即 每组有n个块
  - 直接映射：j = i mod 2^c
    - 主存地址划分结构构：{ 主存字块标记 | Cache字块地址 | 字块内地址 }
    - j Cache行号，i 主存块号，2^c Cache总块数
    - 每个主存数据块只能装入Cache中的固定位置，块位置由 主存块号 mod Cache块号 得出
    - 不使用替换算法，若装入块时产生冲突，无条件替换出原来的块
- 多层Cache：第一层-数据Cache/指令Cache，第二层，第三层
- Cache替换算法：要放入的块已经被占用，无其他可放空块
  - 不考虑局部性原理：随机替换RAND，先进先出FIFO
  - 考虑局部性原理：
    - 最近最少使用LRU：每个块都计数，每次访存时顺序查找Cache，有内容且命中则该块计数器清0，有内容不命中则加1；简单理解，替换 最少使用的块 中 上次被访时间间隔最长的？？
    - 最不经常使用NRU？？LFU？？：每个块都计数，每次访存时顺序查找Cache，有内容且命中则计数器加1，否则不变；简单理解，替换 最少使用的块 中 上次被访时间间隔最长的？？
- Cache读写策略：使Cache内容和主存内容保持一致，主要情景是 改变了Cache块的内容后 如何改对应的主存块的内容
  - 全写法 + 非写分配法
    - 全写法：CPU对Cache写命中，将数据同时写入Cache和主存，需要替换块时新调入的块直接覆盖
    - 非写分配法：CPU对Cache写不命中时，只直接写入主存，不调块
  - 写回法 + 写分配法
    - 写回法：CPU对Cache写命中，只修改Cache内容，当块被换出时才写回主存
    - 写分配法：CPU对Cache写不命中时，调块到Cache并更新Cache
- Cache失效：义务失效，容量失效，冲突失效
- Cache中每块另有 有效位、标记？？表示该块是否已用and存的是主存中哪个块。相联存储器，用于在CUP访存时并行比较 要访问的主存地址 与 Cache中已有标记，若标记相同and有效位=1 则Cache命中
### 主存-辅存层
- 主存、辅存之间直接互相访问
- 虚拟存储技术：解决主存容量不足的问题
- 逻辑地址 = 虚地址 = 虚拟空间，物理地址 = 实地址 = 主存地址空间，虚地址＞实地址
- 使用：CPU通过页表/段表判断虚地址对应的实地址是否已在主存中，在CPU即可通过地址变换后直接访问主存，不在则从辅存调入主存，若主存已满则用替换算法替换
- 虚拟存储器 = 主存 + 联机工作的辅存，将主存or辅存的地址空间统一编址，在硬件和软件系统的共同管理下工作
- 地址翻译：逻辑地址 翻译为 物理地址
  - 页式虚拟存储器
    - 虚拟空间、存储空间均以页为基本单位，一个程序一个页表-页表指出该程序有哪些页
    - 页表：虚页号、实页号的对照表，长久地存于主存中
    - 虚地址 = { 虚页号 | 页内地址 }
    - 页表基址寄存器 = { 页表起始地址 | 页表长（即页表项个数） }
    - 页表项地址 = 页表起始地址 + 虚页号*页表项长
    - 页表项 = { 虚页号 | 实页号 | 装入位 | ... }，装入位=1即该页已在主存中
    - 实地址 = 实页号*页表项长 + 页内地址（实页号 拼接 页内地址？？）
  - 段式虚拟存储器
    - 程序按逻辑结构划分为段，一个程序一个段表
    - 段表：程序的逻辑段、主存中存放位置的对照表
    - 虚地址 = { 段号 | 段内地址 }
    - 段表基址寄存器 = 段表起始地址
    - 段表项地址 = 段表起始地址 拼接 段号
    - 段表项 = { 段号 | 起始地址 | 段长信息 | 装入位 | ... }，装入位=1即该段已在主存中
    - 实地址 = 起始地址 + 段内地址（偏移量）
  - 段页式虚拟存储器
    - 程序按逻辑分段，每段再划分为页，一个程序一个段表，一段一个页表，调入调出以页为基本单位
    - 虚地址 = { 段号 | 段内页号 | 页内地址 }
    - 段表项地址 = 段表起始地址 拼接 段号
    - 从段表项中取出页表起始地址，拼接 段内页号 = 页表项地址
    - 实地址 = 实页号 拼接 页内地址
- 缺页中断的置换算法（容后哪里？？）
  - 置换算法：OPT，FIFO，LRU，Clock（NRU）
- TLB快表：解决地址翻译访存速度慢的问题
  - 快表：保存慢表中最活跃的若干表项的副本，慢表Page = 主存中的页表
  - 同时有TLB和Cache的CPU访问顺序
    - TLB →页表 →Cache →主存 →调页
    - 先找TLB和Page，转逻辑地址为物理地址；后用物理地址找Cache和主存
## 总结区分
- Cache：CPU-主存层级，解决系统速度，硬件实现的硬件存储器，
- 虚拟存储器：主存-辅存层级，解决主存容量，OS和硬件共同实现的逻辑存储器
- Cache：保存主存中最活跃的若干个块的副本
- 地址翻译：快表TLB →页表 →Cache →主存
- 地址映射：把主存中的程序按规则装入Cache
- 地址变换：CPU访存时，将主存地址按规则换算成Cache地址
- 主存：被分为若干大小相等的块
- 页表：虚页号和实页号的对照表，长久地存于主存中，被CPU访问
- 快表：页表中使用频繁的表项的副本，用Cache存？

# 指令系统
- 指令：计算机执行某种操作的命令，计算机运行的最小功能单位，一条指令 = 机器语言的一个语句
- 指令格式：{ 操作码字段 OP | 操作数地址码字段 A1 | A2... }
  - 指令条数≤2^OP，指令操作数的直接寻址范围≤2^A
- 指令格式分类
  - 按指令地址的数量：零地址指令，单地址指令，多地址指令
    - 零地址指令：{ OP }，不需要操作数的指令如关中断or仅在堆栈计算机中取栈顶俩操作数算完结果压入栈
    - 一地址指令：{ OP | A1 }，根据操作码确定指令功能
      - 单操作数，OP (A1) →A1，表示 取A1地址里的操作数，用OP的操作操作一下，结果存入地址A1，类似 +(1011)→1011即取地址1011里的数，加1后存回1011地址
      - 双操作数，(ACC) OP (A1) →ACC，表示 累加器ACC隐含提供操作数，和A1里的操作数进行OP操作，结果存回ACC
    - 二地址指令：{ OP | A1 | A2 }，表示 (A1) OP (A2) →A1，将A1和A2中的两个操作数相OP，结果存入A1
    - 三地址指令：{ OP | A1 | A2 | A3(结果) }，表示 (A1) OP (A2) →A3
    - 四地址指令：{ OP | A1 | A2 | A3(结果) | A4(下址)}，表示 (A1) OP (A2) →A3，A4 = 下一条执行的指令地址
  - 按指令内容的长度：定长操作码指令（OP位数固定），不定长/扩展操作码指令（OP位数不固定，长操作码的前缀不能和短操作码相同）
  - 按功能类型，简单的计算机指令系统三大类型指令
    - 运算类
    - 传送类：eg存储器到寄存器/寄存器到IO
    - 控制类：eg暂停处理器/清除标志位
    - 转移类
  - 按指令内容的性质：操作码，地址码
- 寻址方式：指令寻址、数据寻址
  - A = 地址码 = 形式地址 可以是内存地址也可以是寄存器编号，(A) = A内的数值，EA = 有效地址
    - EA = (A) 表示 有效地址是形式地址A中的数值
  - 指令寻址：寻找下一条将执行的指令的地址，用PC给出结果
    - 顺序寻址：程序计数器 PC + 1（1个指令字长），自动形成下一条指令地址
    - 跳跃寻址：利用转移类指令，本条指令给出下条指令地址，再相应修改PC值
  - 数据寻址：寻找操作数的地址，通常在指令字中增加“寻址特征”字段表明方式，{ OP | 寻址特征 | A }
    - 隐含寻址：只有操作码字段OP，没有操作数地址字段，如单地址格式指令，优点-缩短指令字长，缺点-增存储操作数or硬件
    - 立即寻址：地址码字段A = 操作数本身（又叫立即数），补码存放，优点-不访主存-指令执行时间最短，缺点-A的位数限制了立即数的范围
    - 直接寻址：地址码字段A = 真实地址，EA = A，优点-只访一次主存-简单，缺点-A位数决定操作数寻址范围-A不易修改
    - 间接寻址：地址码字段A = 有效地址，EA = (A)，可一次可多次，优点-扩大寻址范围-便于编程，缺点-多次访存-不常用-常用扩大寻址范围的是寄存器间接寻址
    - 寄存器寻址：地址码字段A = 寄存器编号Ri，EA = Ri，寄存器内为操作数，优点-不访主存-支持向量/矩阵运算，缺点-寄存器少又贵
    - 寄存器间接寻址：地址码字段A = 寄存器编号Ri，EA = (Ri)，寄存器内为操作数地址，优点-比间接寻址快，缺点-指令执行要访存
    - 相对寻址：地址码字段A = 形式地址A，EA = (PC) + A，程序计数器PC加偏移量A为有效地址，优点-便于程序浮动-适用于转移指令，缺点-未提，注-转移指令JMPA在取出字节时会自动(PC)+1指令字长，再加A
    - 基址寻址：地址码字段A = 形式地址A，EA = (BR) + A，基址寄存器BR加偏移量A为有效地址，优点-面向操作系统-扩大寻址范围-利于多道程序设计-编浮动程序，缺点-偏移量A位数短
    - 变址寻址：地址码字段A = 形式地址A，EA = (IX) + A，变址寄存器IX加偏移量A为有效地址，优点-面向用户-扩大寻址范围-利于为多道程序分配存储空间-处理数组问题，缺点-未提
    - 堆栈寻址：多数用无操作数指令，地址由特定寄存器给出，堆栈指针SP，硬堆栈，软堆栈
    - 条件寻址：
## 指令系统的大类划分 CISC RISC
- CISC 复杂指令系统计算机 Complex-Instruction-Set-Computer
  - 指令长度可变，指令形式复杂多变，指令数目＞200，多种访存方式，访存指令不受限，寄存器用的少，一般采用微程序控制，优化编译较难，软件兼容较易
  - 代表：x86指令系统架构
- RISC 精简指令系统计算机 Reduced-Instruction-Set-Computer
  - 指令长度固定，指令形式少而简单，指令数目＜100，只有load/store能访存，寄存器用的多，一般采用硬布线控制，指令流水线技术，需要优秀编译器支持
  - 代表：MIPS指令系统，ARM架构
- CISC代表：x86机器工作模式
  - 传统模式：实模式-从加电启动复位到OS运行之前；保护模式-OS和应用程序的运行；虚拟8086/V86模式-运行兼容8086程序
  - 长模式：64位模式，兼容模式
  - 8086的寄存器
    - 通用寄存器
    - 指令指针寄存器：取指令后自增，保留一个内存地址，指向当前需要取出的指令
    - 标志寄存器：状态标志，控制标志
    - 段寄存器：与其他寄存器联合生成存储器地址-代码段寄存器CS-数据段寄存器DS-附加段寄存器ES-堆栈段寄存器SS；8086物理地址生成过程？？
  - 8086特点
    - 对外：数据线 = 16，地址线 = 20
    - 物理地址 = 段加偏移
    - 存储器中保留两个专用区域：最低1kb-中断向量表区，最高16b-初始化程序区
  - x86指令分类例子
    - 传送指令：传送指令MOV，栈操作PUSH POP，LEA指令
    - 算术运算：ADD ADC INC，SUB SBB DEC，CMP
    - 逻辑运算、位移：NOT AND，SHL，SHR SAR
    - 转移指令：无条件转移JMP，条件转移
    - 处理器控制指令
    - 复杂x86指令：REP前缀-无条件重复；串操作指令-MOVSB字节串传送-方向取决于DF位~0低地址开始~1高地址开始
- RISC代表：MIPS
  - 主要关注点：减少指令类型，降低指令复杂度
  - 基本格式
    - R 寄存器：rs-通常指定第一个源操作数所在的寄存器编号，rt-第二个源操作数所在寄存器编号，rd-目的操作数要放的寄存器编号
    - I 立即数：rs = R中rs，rt-目的操作数所在的寄存器编号，i-立即数
    - J 无条件转移
  - MIPS指令分类例子
  - 运算指令：add sub mul div，and or，sll srl，带u溢出时不报异常，带i操作中有立即数
  - 访存指令：lw sw
  - 分支指令：jr，beq，j


# 中央处理器 CPU
- 功能
  - 指令控制：取指、分析指令、执行指令，即程序的顺序控制
  - 操作控制：产生操作信号完成指令功能
  - 时间控制
  - 数据加工：算术、逻辑运算
  - 中断处理
- 基本组成结构：控制器，运算器，附带寄存器？？
  - 运算器：算术逻辑单元，暂存寄存器，累加寄存器，通用寄存器组，程序状态字寄存器，移位器，计数器等
  - 控制器：程序计数器 PC，指令寄存器 IR，指令译码器，存储器地址寄存器 MAR，存储器数据寄存器 MDR，时序系统，微操作信号发生器等
- 指令执行过程
  - 指令周期：CPU从主存中取出、执行一条指令所需的全部时间，完整 = (取指 + 间址 + 执行 + 中断) 周期
  - 指令周期的数据流
    - 取指周期：由PC内存的指令地址，从主存中取出指令代码，存到IR中
    - 间址周期：取操作数的有效地址
    - 执行周期：由IR重点指令字的操作码、操作数，通过ALU产生执行结果，无统一数据流向
    - 中断周期：处理中断请求
  - 1 指令周期 = 若干 机器周期，1 机器周期 = 若干 时钟周期/节拍T周期
  - 无条件转移指令 JMP X：执行时不访主存，只包含取值、分析、执行
  - 间接寻址访2次主存：取操作数的有效地址、根据地址取操作数
- mips中cpu执行指令：取指 →译码 →执行 →访存 →回写
- 单周期处理器
  - 总体设计步骤
    - 分析指令系统，得出对数据通路的需求
    - 为数据通路选择合适的逐渐
    - 连接组件建立数据通路
    - 分析每条指令的实现，以确定控制信号
    - 集成控制信号，形成完整的控制逻辑
  - 组成部件
    - 算术逻辑单元ALU，立即数扩展部件-零扩展+符号扩展，程序计数器PC，寄存器堆RegFile，存储器，多选器
## 流水线、冒险
- 指令流水线技术
  - 切分单周期处理器，之间添加流水线寄存器
  - 单挑指令的执行时间不变，指令吞吐率提高
  - 流水线的无限制加深 = 时钟的主频提升 ≠性能提升
- 超标量技术：多条并行工作的流水线结构
- 多核CPU
- 并行性
  - 时间并行性：主要是对现有硬件的切分，eg：单周期to标量流水线
  - 空间并行性：需要成倍增加硬件资源，eg：标量to招标量流水线
- 局部性
  - 时间局部性：最近访问的存储器单元（指令or数据）很快还会被访问，eg：SUM、循环指令
  - 空间局部性：正在被访问的存储单元**附近**的单元很快会被访问，eg：数组
- 流水线与冒险
  - 数据冒险：周期停顿，产生空泡；数据旁路
  - 结构冒险：周期停顿，产生空泡；将一周期的工作分为前半个周期写，后半个周期读；单独设置存储器、寄存器；指令cache和数据cache
  - 控制冒险
    - 周期停顿，产生空泡
    - 不同类型转移指令的影响：无条件直接转移-流水线不停，无条件间接-流水线停一周期，条件转移-流水线停一周期
    - 延迟转移技术：用转移指令延迟来安排无关指令执行位置
    - 分支预测，预取指令


# 总线
- 分类：片内总线，系统总线，通信总线
- 仲裁：集中式，分布式
  - 集中式：链式查询，计数器定时查询，独立请求
- 通信
  - 同步：统一时钟
  - 异步：握手 = ｛不互锁，半互锁，全互锁｝

# 输入/输出系统与中断
- I/O接口
  - 基本功能：数据缓冲，提供联络信息，信号与信息格式转换，设备选择，中断管理，可编程功能
  - 基本结构：数据输入寄存器，数据输出寄存器，状态寄存器，控制寄存器，中断控制寄存器
  - I/O端口编址
    - 和存储器统一编址：RISC如MIPS采用，指令功能齐全-直接处理IO端口内数据，简化内部结构，占用存储地址空间，指令长度、执行时间相对较长
    - 和存储器分开编址：CISC如x86采用，IO端口不占用存储器地址，IO指令编码短、执行速度快，地址码短、地址译码方便，层次清晰便于理解，功能较单一，独立的控制逻辑、内部结构复杂
- I/O方式
  - 无条件传送：如单片机控制小灯泡
  - 程序查询：工作流程？？，CPU与IO串行
  - 程序中断：工作流程？？，CPU与IO并行，但CPU频繁响应中断
  - DMA方式
    - DMA控制器：DMAC
    - DMAC主要配置参数-CPU设置：源地址初始值、传送时的地址增减方式，目的地址初始值、传送时的地址增减方式，待传送数据的长度
    - DMA工作方式流程？？，专有数据传输不经过CPU
  - 通道方式：专用处理器
- 外设？？
## 中断
- 中断向量表
  - 保存在存储器地址最低的一部分
  - 存储中断服务程序的入口地址 = 中断向量
  - 计算？？
  - 保护模式的中断操作
    - 描述符地址 = 类型号 + IDTR
    - 获得CS和EIP
    - CS和GDTR得到段基值
    - 段基值和DIP得到真正保护程序的入口地址
- 中断处理流程
  - 中断隐指令 = 硬件：关中断 →保存断点 →识别中断源
  - 中断服务程序 = 软件：保护现场 + 中断屏蔽字 →若有多重中断则开中断 →恢复现场并返回，通过IRET或IRETD(32)/IRETQ(64)指令实现中断返回
- 中断指令：INT n
- 中断分类：内、外
  - 内中断：除了3=单字节指令，其他都是双字节指令，只有1能被软件方式屏蔽
    - 4 溢出中断：溢出标志位 OF = 1 进入中断，用于检验的INTO指令通常安排在算术运算指令之后
    - 3 断点中断：设置断点，通常与单步中断配合使用；唯一单字节指令，为保证设置断点用INT 3替换原有指令时，不影响其他指令运行
    - 2 非屏蔽中断
    - 1 单步中断：用于错误调试，TF = 1 时进入单步工作方式，唯一能通过软件方式屏蔽的内中断
    - 0 除法错中断
  - 外中断：IF标志位控制是否屏蔽
- 利用中断功能的调用：利用寄存器传入参数
  - BIOS中断 1AH：读取、设置时钟
  - DOS中断 21H：屏幕输出字符
- 多重中断
- 中断屏蔽技术、中断判优：中断屏蔽字
