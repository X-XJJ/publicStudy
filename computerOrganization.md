# n进制
## 二进制 十进制 十六进制 互转



# 定点数、浮点数
V = (-1)^s x M x 2^e
V = (-1)^s x M x 2^(e^-127)
符号位(-1)^s 

尾数 基数 指数 偏移量

符号位1位 e-8位 M-23位

S e M

7.00 = 3.5 x 2^1 = 1.75 x 2^2

https://www.cnblogs.com/icmzn/p/5060195.html


小数是怎么表示在内存中的
首先有定点数和浮点数的两种概念

定点数:
    小数点的位置不用特定的表示出来,它是有一个约定的固定位置
    如果无需关心其正负性,那么符号为将用于表示数值,无符号数所能表示的数值与有符号数所能表示的数是一样的
    
    我们以32位的一个数值为例
    定点数的内存结构为,第1位为符号位,第2-9位为整数位,10-32位为浮点位
    假设我们有一个小数8.25
    那么0(符号位)1000(整数位)01(2^-2)=0.25

浮点数:
    它不会在意小数点的位置
    其中:浮点数的第一位为符号位,2-9为指数位(以2为底(指数位决定了其精度),其中指数位称为阶码),后面的10-32为数值位(尾数位)(数值位标识了其可存储的最大数值)
    其中:双精度浮点数在精度上比float翻倍,double预留了11位来保存指数位
    其中:浮点数的实际尾数位为24,而双精度的实际尾数位为54

    示例:
    我们现在有一个数8.25
    整数部分就可以化为二进制1000
    小数部分就可以化为01
    那么该数的二进制形式就是1000.01->将其科学计数为1.0001*2^3
    由于科学计数后它的第一位都是1,那么就不用表示,本来23位,53位的实际内存就能表示24/54的数据
    
    那么,24位能精确到小数点后多少位呢?
    首先:9的二进制为1001,所以4bit能精确表示十进制的一位小数点,
    那么24位大概能表示6-7位

    那么,对于指数部分,因为指数可正可负,8位的指数实际的范围就是-127到128
    其中指数从00000000(-127)开始,到11111111(+128)结束
    
    IEEE规定的是指数偏移
    IEEE规定了一个固定值2的e-1次方-1
    以单精度为列,它的指数域是8bit,固定偏移值是2的8-1次方-1=127
    比如说,指数实际数值是17(10进制),而其编码值则为17+127=144
    那么,它的表示方式也就是不表示负数部分,以一个正数-127的方式来计算它的指数

    
    注:使用浮点数注意事项
        1.请不要用一个数值特别大的数来加一个数值特别小的数,因为这样子等于没加
        2.浮点数计算结果出错问题
        比如说0.4我们要0.4的话->就是0.25+0.125+0.0625->.....
