# 相关其他
## java内存池
- 一般的系统接口申请内存：
- C/C++ malloc/free
- java new/delete
- 在内存碎片中寻找最接近申请大小的内存块，返给申请者，容易造成众多小块内存碎片无法利用
- 内存池：
  - 定长分配，每次分配固定长度
  - 变长分配
- 定长分配：每次申请固定长度，使用时利用栈，例如存储一个变量，申请malloc内存，便入栈一个，直到这个长度的内存使用完毕，再一次申请定长内存；free即出栈


# 基本概念
- 计算机系统划分：硬件 →操作系统 →应用程序 →用户（与计组分层不同）
- 操作系统 Operating System，是一种系统软件，如Windows，Linux
- 特征：并发，共享，虚拟，异步
  - 并发-最基本：同一时间间隔Δt内存在多个运行的程序（并行：同一时刻，需相关硬件才行）
    - 为此引入“进程”，并通过分时实现并发
  - 共享-最基本：即资源共享，系统资源可供内存中多个并发执行的进程共同使用
    - 互斥共享：一段时间内只允许一个进程访问，如打印机、磁带机
    - 同时访问：宏观同时访问；微观交替访问、分时共享、一个请求分几个时间片间隔完成
  - 虚拟：一个物理上的实体变为若干个逻辑上的对应物
    - 时分复用技术：处理器的分时共享
    - 空分复用技术
      - 虚拟处理器：一个物理CPU虚拟为多个逻辑上的CPU，分别服务多个不同的用户
      - 虚拟存储器：一个物理存储器转为虚拟存储器，从逻辑上扩充存储器的虚拟容量
  - 异步：进程的执行走走停停，以不可预知的速度向前推进
- 功能
  - 管理计算机系统资源（OS关注）
    - 处理器管理（进程管理）：进程控制，进程同步，进程通信，死锁处理，处理机调度等
    - 存储器管理（内存管理）：内存分配和回收，地址映射，内存保护与共享，内存扩充，代码兑换程序等
    - 文件管理：文件存储空间管理，目录管理，文件读写管理和保护等
    - 设备管理（如IO）：缓冲区管理，设备分配，设备处理，设备回收，虚拟设备等
  - 是用户与硬件的接口
    - 命令接口
      - 联机or交互式：适用分时or实时系统，为一组键盘操作命令
      - 脱机or批处理式：适用批处理系统，为一组作业控制命令
    - 程序接口：在编程程序中使用，为一组系统调用命令，UI（本质是程序）接口，图形用户界面GUI即图形接口
  - 计算机扩展：裸机歪成为操作系统，虚拟机 = 覆盖软件的机器 = 扩充机器
- 发展：批处理OS-单道/多道，分时OS-关键是交互，实时OS-硬实时/软实时-关键是及时&可靠，分布式OS-多机协同完成同一任务，网络OS-资源共享&多机通信，个人OS，嵌入式OS等
- OS状态：用户态（目态），核心态（管态）
- 核心态：状态切换 + 内核
  - 状态切换/系统调用
    - 设备管理，文件管理，进程通信，进程控制，内存管理
    - 系统调用：用户在程序中调用OS提供的子功能；系统调用开始在用户态，执行在内核态，最后返回用户态
  - 内核
    - 时钟管理：时钟是最关键的设备
    - 中断机制：小部分功能属于内核，即保护和回复中断现场的信息，转移控制权到相关处理程序
    - 原语：不可中断，最底层公用的小型程序，完成一个规定的操作，时间短，调用频繁
    - 系统控制的数据结构&处理
      - 数据结构：作业控制块，进程控制块PCB，设备控制块，各类链表，消息队列，缓冲区，内存分配表，空闲区登记表等
      - 操作处理：进程管理，存储器管理，设备管理
- 硬件实现中断&异常
  - 中断：外中断，来自CPU指令以外的事件，如设备IO中断，时钟中断
    - 强迫中断——外设请求or人的干预
  - 异常：内中断/例外/陷入，主动进入or系统调度，源自CPU指令内部的事件，如地址越界，算术溢出
    - 强迫中断——硬件故障or软件中断
    - 自愿中断——指令中断
  - 硬件实现中断和异常，是唯一从用户态进入核心态的途径
- 体系结构：大内核，微内核
- 计算CUP利用率

# 进程管理
- 进程：系统资源进行分配和调度的最小单位（“时间片”分配）
  - 目的；实现OS多道程序的并发、共享
  - 唯一标志：进程控制块 PCB Process-Control-Block
    - 进程创建时创建，常驻内存，任一时刻可存取，进程结束时删除
    - 主要包括：进程描述信息（进程标识符，用户标识符），进程控制&管理信息（当前状态、优先级等），资源分配清淡，处理机相关信息 P32
    - PCB组织方式：链接方式（队列），索引方式（索引表）
  - 特征：动态性（最基本），并发性，独立性，异步性，结构性
  - 进程结构 = 进程实体 = 进程映像 =  PCB + 程序段 + 相关数据段，静态
- 进程状态切换
  - 五状态模型：创建，就绪（基本），运行（基本），阻塞（基本），终止
    - 转换：创建 →就绪 →运行 [→阻塞/等待 →就绪 →运行] →结束
    - 就绪：仅缺少处理机，被动等唤醒原语Wakeup变就绪
    - 阻塞：除处理机外需等待其他资源or某一事件，主动调阻塞原语Block变阻塞
  - 七状态模型：五状态添加 就绪挂起，阻塞挂起
- 线程：系统独立调度的基本单位，基本的CPU执行单元
  - 目的：减小程序并发执行时的时空开销
  - 组成：线程ID，程序计数器，寄存器集合，堆栈
  - 实现：用户级线程-应用程序完成所有线程管理-内核不知，内核级线程-内核完成所用线程管理-应用程序只有接口，混合型
  - 多线程模型
    - 一对一：一个用户级线程映射一个内核级线程
    - 多对一：多个用户级线程映射到一个内核级线程，线程管理在用户空间完成
    - 多对多：n个用户级线程映射m个内核级线程，m≤n
- 进程间通信
  - 低级：PV操作
  - 高级：共享存储（共享空间），消息传递-格式化消息为单位-直接通信（缓冲队列）/间接通信（电子邮件），管道通信（管道 = 共享文件），IPC
- 作业：用户要求计算机完成的一串任务
## 处理机调度（CPU调度）
- 调度：决策行为，决定资源分配给哪个进程
- 切换：执行行为，实际进行分配操作
- 作业从提交到完成的调度层次：三级调度 P51
  - 高级调度/作业调度：创建进程、获得竞争处理机的权利，分配内存、设备等必要资源，内存-辅存层，每个作业只调入一次，调出一次，频率最低
  - 中级调度/内存调度：提高内存利用率、系统吞吐量，进程挂起/调到外存等待、唤醒调入内存就绪，频率次低
  - 低级调度/进程调度：按某种方法策略从就绪队列选出进程、为之分配处理机，最基本，频率最高
- 进程调度方式
  - 非剥夺/非抢占式调度：让当前进程执行完成，适用批处理系统，如先来先服务，短作业优先？
  - 剥夺/抢占式调度：立即暂停当前执行的进程，适用分时、实时系统，如最短剩余时间，短进程优先，优先级调度，轮转调度？
- 调度算法性能比较准则：最大化CPU使用率、吞吐量，最小化三个时间
  - CPU利用率：尽可能高
  - 系统吞吐量：单位时间内CPU完成作业的数量
  - 周转时间 = 作业完成时间 - 作业提交时间
    - 平均周转时间 = n个作业的周转时间和 / n
    - 带权周转时间 = 作业周转时间 / 作业实际运行时间
    - 平均带权周转时间 = n个作业的带权周转时间和 / n
  - 等待时间：进程处于等待处理机的状态的时间总和，与处理机调度算法有关
  - 响应时间：用户提交请求到系统首次产生相应的时间
  - 平均等待时间 = (总周转 - 总执行) / 完成的进程数
- CPU周期：
### 典型调度算法
- 分情况适用于作业调度、进程调度、二者都适用
- 先来先服务 FCFS，First-Come-First-Serve，二者适用
  - 不可剥夺，公平，适用短进程，IO进程不友好
  - FIFO队列实现，性能受进程时间+到来顺序影响大
  - 问题：护航效应，允许大进程长期占用CPU时间，其他进程都在等
- 短作业/进程优先 SJF SPF，Shortest-Job/Progress-First，二者适用
  - 优先CPU周期（执行时间）最短的，最短/最优平均等待时间、平均周转时间
  - 问题：长进程饥饿，无法准确获取CPU周期，使用指数平均方法预测
- 优先级调度算法 Priority scheduling，二者适用
  - 分类：非剥夺式，剥夺式
  - 优先级分类：静态-创建进程时确定优先级且保持不变，动态-进程运行过程中动态调整优先级
  - 问题：低优先级无穷阻塞/饥饿
  - 解决：老化思想，逐渐增加等待时间长的进程的优先级
- 最高相应比优先调度算法，作业调度
  - 响应比 Rp = (等待时间 + 要求服务时间) / 要求服务时间
  - 改进的FCFS、SJF，不会饥饿，计算开销大
- 时间片轮转调度算法 RR，Round-Robin scheduling，分时系统
  - 一个就绪队列，执行队首进程，在Δt内没完就超时中断，放到就绪队列队尾
  - 时间片Δt通常大小 = 10~100ms，时间片的选取和轮转效率挂钩
  - 实时性好，利于交互，进程切换开销大
- 多级反馈队列调度算法 Multilevel-Feedback-Queue
  - 实现过程
    - 多个就绪队列，赋予不同的队列优先级和时间片，第一级优先级最高
    - 优先级越高↑的队列中，每个进程运行的时间片越小↓
    - 新进程先进入第一级队列末尾排队，轮到它时在第一个时间片内没完成，便调入第二级队列末尾排队，以此类推
    - 仅当第一级队列空时，才运行第二级队列的进程；被抢占则先放入当前级队列末尾排队
  - 改进的时间片轮转、优先级调度，综合性强，不同长度时间片队列
  - 问题：可能饥饿
- 多级队列调度 Multilevel-Queue
- 最短剩余时间算法 SRTF，Shortest-Remain-Time-First scheduling
  - 允许抢占的SJF
  - 就绪队列进程的剩余执行时间＜正在执行的进程的剩余执行时间，就抢占
- 睡眠排序是根据哪个cpu调度算法？？
## 进程同步、互斥
- 目的：控制多道OS进程的异步性、临界资源的互斥访问
  - 临界资源：一次仅允许一个进程使用的资源，必须互斥访问，临界区 = 访问临界资源的代码
  - 同步：直接制约，协作关系，进程间相互合作完成一个任务，需要在某些位置上协调进程之间的工作次序，在关键点上等待另一个进程发来的消息
  - 互斥：间接制约，竞争关系，一个进程进入临界区使用临界资源时，其他进程必须等待，只能逐一使用临界资源
  - 临界区原则：空闲让进，忙则等待，有限等待，让权等待
- 互斥的软件实现：单标志法，双标志法先检查，双标志法后检查，Peterson算法（flag解决临界区的互斥访问，turn解决饥饿现象）
- 互斥的硬件实现：中断屏蔽，硬件指令-硬件逻辑直接实现 TestAndSet指令（读并设标志为真）+ Swap指令（交换）
- 信号量机制-解决互斥和同步问题
  - PV操作，PV原语，原子操作，不可中断
    - P(S) = wait(S) 阻塞原语，申请资源，S = S-1，资源已占则block(P)，Proberen（测试，荷兰语）
    - V(S) = signal(S) 唤醒原语，释放资源，S = S+1，有进程等则wakeup(P)，Verhogen（增加，荷兰语）
    - S = 信号量（可不止一个，初值看情况设置）
      - 整型信号量：整型S表示资源数目，wait中会不断测试从而“忙等”
      - 记录型信号量：记录型数据结构semaphore S = {资源数目value，进程链表L}，L链接所有等待该资源的进程P们
  - 进程同步实现：两个进程中分别P和V，如需要在P1执行语句x后执行P2，则进程P1中x后V(S)表示P1已完成x，进程P2中P(S)查询x是否完成
  - 进程互斥实现：一个进程中访问临界区前后进行PV，P(S)申请资源 →访问 →V(S)释放资源
  - 实现进程前趋关系：前趋关系图，使用进程同步
- 管程
  - 一组数据和定义在数据上的对数据的操作组成的软件模块
  - 组成：局部与管程的共享结构数据说明，对改数据结构进行操作的一组过程，对局部于管程的共享数据设初值的语句
  - linux中HORE管理-A等B执行，MESA管理-B等A执行
- PV操作问题们
  - 信号量值的隐含信息：S＞0 可用资源个数S，S=0 该资源用完，S＜0 等待进程个数S
  - 互斥访问变量 Semaphore S，P总数 = V总数
  - 生产者消费者问题
    - 生产者、消费者共享一个初始为空、大小为n的缓冲区，同一时刻只能有一方操作缓冲区，不满可生产，不空可取
    - 有数据缓冲区信号量 full = 0，空缓冲区信号量 empty = n，临界区互斥信号量 mutex = 1
    - 对缓冲区的操作互斥，full和empty联动表示缓冲区状况
  - 读写者问题
    - 读者、写者共享一个文件，可同时读，只可有一个写，读写不能同时
    - 当前读者数量 count = 0，读写互斥 rw = 1，控制互斥修改count mutex = 1，写优先信号量 w = 1
    - 读者不互斥-添加循环
  - 哲学家就餐问题
    - 圆桌上一圈哲学家，两两之间有一根筷子，一根一根地拿到两根筷子可以进餐
    - 筷子资源互斥信号量数组 chopstick[5] = {1,1,1,1,1}，互斥取筷子动作的信号量 mutex = 1
    - 同时考虑能拿起两支筷子，防止死锁（思想与贪心算法相反）
  - 吸烟者问题
    - 一个供应者无限随机提供三种材料中的两种，三个抽烟者分别持有一种材料，抽烟者集齐三种材料可抽烟
    - 烟草和纸的信号量 offer1 = 0，烟草和胶水的 offer2 = 0，纸和浇水的 offer3 = 0，抽烟是否完成 finish = 0
- 自旋锁
## 程序出错
- 死锁：多个进程因竞争不可剥夺资源造成的互相等待/阻塞的僵局，若无外力作用则无法向前推进
  - 充要条件：互斥，不可剥夺，请求保持，循环等待
- 死锁处理策略：预防，避免，检测和解除
- 死锁预防：死锁发生前，破坏死锁产生的条件之一or之几
  - 破坏互斥：不太可行
  - 破坏不剥夺：常用于状态易保存和恢复的资源，如CPU寄存器、内存，一般不能用于打印机之类的
  - 破坏请求和保持；预先静态分配方法，进程运行前一次申请完所有资源，都满足才能运行，直到运行结束释放资源
  - 破坏循环等待：顺序资源分配法，进程按编号递增的顺序申请资源，同类资源一次申请完
- 死锁避免：死锁发生前，在资源的动态分配过程中，防止系统进入不安全状态
  - 安全状态：可避免死锁，系统能按某种进程执行并释放资源的顺序序列，动态地按序为每个进程Pi分配所需最大资源，使之都能顺利完成
  - 不安全状态：死锁必为不安全状态，不安全状态必定？可能？但非立刻进入死锁
  - 银行家算法：
    - 数据结构描述
      - 可用资源矩阵 Available[m] = K，    资源类 = m，第m类资源的可用数目 = K
      - 最大需求矩阵 Max[n][m] = K，       进程数 = n，第n个进程申请第m类资源的最大需求 = K
      - 分配矩阵     Allocation[n][m] = K，进程数 = n，第n个进程已分配的第m类资源数 = K
      - 需求矩阵     Need[n][m] = K，      进程数 = n，第n个进程还需要的第m类资源数 = K
      - Need = Max - Allocation
      - 进程Pi请求   Request[j] = K，      第i个进程为Pi，请求第j类资源数 = K
    - 算法描述
      - 当进程Pi请求第j类资源K个，按以下顺序进行检查，成功则往下，否则Pi需等待
      - 1、请求j类K个＜需求j类k个
      - 2、请求＜可用
      - 3、假设已经分配K个给进程Pi，计算出已分配后各个矩阵/资源的变化情况
      - 4、在此情况下执行系统的安全性算法，检查系统是否为安全状态
    - 安全性算法（安全状态）
      - 思想：找到一个能把进程都一个个顺着执行完的资源分配顺序，进程执行顺序序列 = 安全序列
      - 1、进程Pi当前时刻Need＜可用Available，将Pi所Need的全分配给Pi
      - 2、Pi执行完释放资源，更新各个矩阵，再找下一个满足条件的Pi
      - 3、若能顺利执行完所有进程，则安全
  - MOOC中三角平面图：
- 死锁检测、解除：不进行限制，允许发生思索，通过检测机构检测，采取措施解决死锁
  - 资源分配图
    - 一个圆圈 = 一个进程，一个方框 = 一类资源，方框中的一个圆点 = 该类资源中的一个资源
    - 请求边 = 进程到资源的有向边 = 进程正在请求一个该资源
    - 分配边 = 资源到进程的有向边 = 该资源已经有一个分配给进程
    - 图形资源固定，以边表示当前的分配状态
  - 死锁检测：死锁发生时
    - 死锁定理：S为死锁 <=> S状态的资源分配图是不可完全简化的，完全简化 = 能消去所有边
    - 用进程资源分配图检测死锁状态，思路类似系统安全状态检查
    - 找能被满足请求的资源的进程，满足后释放，去掉该进程的请求边和分配边，再找下一个
  - 死锁解除：资源剥夺，撤销进程，进程回退
- 活锁：进程正常调度，不阻塞，但是无进展，如：无意义地一直while循环
- 饥饿：由分配调度策略导致，某个进程一直阻塞，进程在信号量内无穷等待


# 内存管理
- 内存管理：操作系统对内存的划分、动态分配（主存中不可能放下全部用户进程和系统程序数据）
- 功能：内存空间的分配和回收，地址转换，内存空间扩充，存储保护
- 程序执行过程：编译 →链接 →装入
  - 编译：产生若干个目标模块 + 其自身的逻辑地址
  - 链接：形成整体逻辑地址 = ｛静态链接，装入时动态链接，运行时动态链接｝
  - 装入
    - 绝对装入：连续，物理地址 = 虚拟地址
    - 可重定位装入：连续，静态重定位，一次性全装入
    - 动态运行时装入：可离散，动态重定位，进程使用时现装入，使用重定位寄存器
- 内存保护
  - 越界保护：越界中断
  - 上下限寄存器
  - 基址、限长寄存器：与限长寄存器比较，与基址寄存器相加
- 覆盖：用户空间分层固定区和覆盖区，基本不用
- 交换：与中级调度相关，不同进程or作业之间进行，广泛使用
- 工作集 = 驻留集：某段时间间隔内，进程要访问的页面集合
- 地址重定位，地址翻译，高位地位，表示的进制？？
- 访存时间，考虑块表 + 缺页中断
## 内存分配
- 连续分配
  - 单一连续分配：只适用于单用户
  - 固定分区分配：会产生内碎片，分区大小相等or不等
  - 动态分区分配：666？？
    - 分配算法：首次适应，最佳适应，最坏适应，临近适应
    - 外部碎片处理：紧凑技术
  - 伙伴分配：对半分 + 合并，最合适大小 (2^n)-1 ＜ x ＜ 2^n
- 非连续分配
  - 管理元素
    - 页表项 = 页号 + 对应块号
    - 页表 = 页表项的集合
    - 逻辑地质结构 = 页号 + 页内偏移量
    - 单位大小：页，页框，块
    - 块表TLB：联想寄存器，基于局部性原理
  - 基本分页存储管理：有内碎片，单级页表，多级页表-最顶级页表只能有一页
  - 基本分段存储管理：有外碎片，段表-二维，依逻辑分段，段内连续，段间不连续
  - 段页式存储：段表页表结合，一个进程只有一个段表，可有多个页表
## 虚拟内存管理
- 虚拟内存：逻辑上扩充内存，基于局部性原理
- 对用户完全透明，远大于实际内存，取决于系统位数
- 特性：多次，对换，虚拟
- 缺页中断：属于系统异常
- 页面置换算法
  - 最佳置换 OPT：存在于理论，多用于比较其他算法优劣
  - 先来先置换 FIFO：可能有Belady异常
  - 最近最久未使用 LRU：堆栈类，使用寄存器
  - Clock算法/NRU算法：指针循环扫描，考虑指针初始位置
  - 改进Clock：考虑页面修改
  - 驻留集算法
- 页面分配策略
  - 固定or可变置换：每个进程分配物理块数目固定or可变
  - 全局or局部置换：置换发生在程序自身物理快内or所有程序内，不存在固定分配全局置换
- 带虚拟存储的内存分配：请求页式存储，请求段式存储，请求段页式存储
- 颠簸现象：即抖动

# 文件管理
- 文件控制块 FCB，File Control B？？
- 文件目录系统
## 用户角度
- 用户进行输入输出，以文件为基本单位
- 文件组成：一块存储空间 + 其中数据，分类 + 索引信息，访问权限信息
- 文件结构：数据项-最低级的数据组织形式，记录-相关数据项集合
- 逻辑结构：无结构-流文件，有结构 =｛顺序结构文件，索引文件，索引顺序文件，散列文件｝
- 文件操作-系统调用
  - 创建Create：申请目录项创建FCB，申请磁盘块
  - 打开Open：返回文件描述符，文件信息填入打开文件表
  - 指针定位Seek：为后续读写操作服务
  - 读Read，写Write，文件重定位，删除，复杂组合操作
- 文件分类：普通文件，特殊文件，目录文件，管道文件，套接字等
- 文件目录
  - 实现：线性链表，哈希表
  - 结构组成
    - 文件目录项：文件控制块FCB，索引节点 + i节点
    - 文件目录：属于目录文件，目录项对应的集合
  - 执行方式
    - 找到 指定目录FCB →下级目录FCB →指定文件FCB
    - 找到 索引节点 →对应i节点 →...
  - 目录类型：与访盘次数结合考虑
    - 单级目录-无法实现多用户&文件不可重名，多级目录，树形目录-使用最普遍，环形目录-实现文件共享
- 文件访问：相对路径，绝对路径
- 文件共享：与共享文件的增删结合考虑
  - 软链接-基于符号链-Link文件，硬链接-基于索引节点
- 文件保护：口令保护，密码保护，访问控制-rwx指令类型
- 文件系统备份：增量备份-备份快恢复慢，全量备份-备份慢恢复快
## 操作系统角度
- 层次结构：用户调用接口 →文件目录系统 →存取控制验证 →逻辑文件系统+文件信息缓冲区 →物理文件系统 →分配模块 →设备管理程序模块
- 文件分配
  - 连续分配
  - 链接分配：隐式链接，显式链接-FAT表
  - 索引分配：直接索引，单级索引，多级索引，多级混合索引-UNIX中三级索引结构+分析文件大小计算
- 文件存储空间管理
  - 空间划分：内存 + 磁盘
  - 磁盘部分
    - 磁盘分区-物理，文件卷-逻辑，格式化，目录文件，用户文件
    - 引导区：UFS引导块，NTFS分区引导扇区，位于启动磁盘or系统盘中，用于引导系统
    - 卷，分区信息：UFS超级块，NTFS主控文件表，用于所在文件卷的管理
  - 内存部分：所有安装分区的信息，系统打开文件表，单个进程打开文件表
  - 管理方式：空闲表法，空闲链表法，位视图？位示图？法，成组链接法
- 物理存储
  - 磁盘读写结构：磁头-磁道，柱面，扇区
  - 磁盘读写操作：寻道时间，延迟时间，传输时间
  - 磁盘调度算法
- 磁盘调度算法
  - 先来先服务 FCFS
  - 最短寻找时间优先 SSTF
  - SCAN
  - C-SCAN
  - 旋转调度算法：考虑处理时延，同磁头不同扇区，不同磁头相同编号扇区，不同磁头不同编号扇区
- 个人OS的文件系统
  - Windows：FAT32，支持Unicode-两字节表示一个字符，支持长文件名格式，多个目录项
  - UNIX：UNIX V，UNIX三级混合文件索引，FCB拆分为索引目录项 + i节点

# 输入/输出管理(I/O)
- IO设备分类
  - 按使用特性：人机交互类，存储设备，网络通信设备
  - 按传输速率：低速，中速，高速
  - 按信息交换的单位：块设备，字符设备
- IO控制方式
  - 程序直接控制：CUP始终占用
  - 中断驱动方式：每传输完成一个字符，CPU占用一次
  - DMA方式：开始时、结束时 CPU占用
  - 通道控制方式：自主权更高
- IO系统层次结构
  - 用户层IO软件：服务于用户
  - 设备独立性软件：设备无关性，映射逻辑设备与物理设备
  - 设备驱动程序：为IO系统隐藏设备控制器之间的差异
  - 中断处理程序：进程上下文切换
  - 硬件设备：电子部分-设备控制器即适配器，机械部分
- IO编址：IO独立编址，占用内存编址
- IO进程：专门处理OS中的IO中断与IO请求
- 设备分配
  - 相关数据结构
    - 设备控制表DCT，控制器控制表COCT，通道控制表CHCT，系统设备表SDT
    - DCT COCT 一一对应，CHCT 一对多个 COCT，一个系统中只有一个SDT
  - 主要考虑因素：设备固有属性，分配算法，分配安全性，独立性
  - 策略：静态分配-用于独占设备，动态分配-可能死锁，相关算法-先请求先分配、优先级分配
  - 安全性：安全分配方式-CPU、IO串行工作-效率低，不安全分配-可能死锁
- Spooling技术：空间换时间
  - 意义：提高IO总体速度，将独占设备改为共享，实现虚拟设备，缓和CPU高速与IO低速的矛盾
- IO性能相关
  - 缓冲技术-缓冲区：单缓冲区，双缓冲区，循环缓冲区，缓冲池-生产者消费者问题
  - 高速缓存技术：利用局部性原理，关联LRU算法
  - 异步IO
  - 异步传输技术
  - 信息优化分布
  - RAID技术：RAID 0条带化，RAID 1镜像，RAID 4交错块奇偶校验
## 核心子系统
- 高速缓存
- 缓冲区
