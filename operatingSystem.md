结合图像理解！！脑子里要有动态图过程图！！
四科全需补图、补例子！

# 一、基本概念
- 计算机系统划分：硬件 →操作系统 →应用程序 →用户（与计组分层不同）
- 操作系统 Operating System，是一种系统软件，如Windows，Linux
- 主存 = 内存，辅存 = 外存
- 特征：并发，共享，虚拟，异步
  - 并发-最基本：同一时间间隔Δt内存在多个运行的程序（并行：同一时刻，需相关硬件才行）
    - 为此引入“进程”，并通过分时实现并发
  - 共享-最基本：即资源共享，系统资源可供内存中多个并发执行的进程共同使用
    - 互斥共享：一段时间内只允许一个进程访问，如打印机、磁带机
    - 同时访问：宏观同时访问；微观交替访问、分时共享、一个请求分几个时间片间隔完成
  - 虚拟：一个物理上的实体变为若干个逻辑上的对应物
    - 时分复用技术：处理器的分时共享
    - 空分复用技术
      - 虚拟处理器：一个物理CPU虚拟为多个逻辑上的CPU，分别服务多个不同的用户
      - 虚拟存储器：一个物理存储器转为虚拟存储器，从逻辑上扩充存储器的虚拟容量
  - 异步：进程的执行走走停停，以不可预知的速度向前推进
- 功能
  - 管理计算机系统资源（OS关注）
    - 处理器管理（进程管理）：进程控制，进程同步，进程通信，死锁处理，处理机调度等
    - 存储器管理（内存管理）：内存分配和回收，地址映射，内存保护与共享，内存扩充，代码兑换程序等
    - 文件管理：文件存储空间管理，目录管理，文件读写管理和保护等
    - 设备管理（如IO）：缓冲区管理，设备分配，设备处理，设备回收，虚拟设备等
  - 是用户与硬件的接口
    - 命令接口
      - 联机or交互式：适用分时or实时系统，为一组键盘操作命令
      - 脱机or批处理式：适用批处理系统，为一组作业控制命令
    - 程序接口：在编程程序中使用，为一组系统调用命令，UI接口（本质是程序），图形用户界面GUI（即图形接口）
  - 计算机扩展：裸机歪成为操作系统，虚拟机 = 覆盖软件的机器 = 扩充机器
- 发展：批处理OS-单道/多道，分时OS-关键是交互，实时OS-硬实时/软实时-关键是及时&可靠，分布式OS-多机协同完成同一任务，网络OS-资源共享&多机通信，个人OS，嵌入式OS等
- OS状态：用户态（目态），核心态（管态）
- 核心态：状态切换 + 内核
  - 状态切换/系统调用
    - 设备管理，文件管理，进程通信，进程控制，内存管理
    - 系统调用：用户在程序中调用OS提供的子功能；系统调用开始在用户态，执行在内核态，最后返回用户态
  - 内核
    - 时钟管理：时钟是最关键的设备
    - 中断机制：CPU检测中断信号，小部分功能属于内核，即保护和回复中断现场的信息，转移控制权到相关处理程序
      - 硬件：自动保存被中断程序的断点，找中断信号对应的中断向量（中断向量指明中断服务程序入口地址，中断向量放在中断向量表中）
      - 操作系统：初始化中断向量表，执行中断服务程序，保存PSW、中断屏蔽字、各通用寄存器值等
    - 原语：不可中断，最底层公用的小型程序，完成一个规定的操作，时间短，调用频繁
    - 系统控制的数据结构、操作处理
      - 数据结构：作业控制块，进程控制块PCB，设备控制块，各类链表，消息队列，缓冲区，内存分配表，空闲区登记表等
      - 操作处理：进程管理，存储器管理，设备管理
- 硬件实现中断&异常
  - 中断：外中断，来自CPU指令以外的事件，如设备IO中断，时钟中断
    - 强迫中断——外设请求or人的干预
  - 异常：内中断/例外/陷入，主动进入or系统调度，源自CPU指令内部的事件，如地址越界，算术溢出
    - 强迫中断——硬件故障or软件中断
    - 自愿中断——指令中断
  - 硬件实现中断和异常，是唯一从用户态进入核心态的途径
- 体系结构：大内核，微内核
- 计算CUP利用率

# 二、进程管理
- 进程：系统资源进行分配和调度的最小单位（“时间片”分配）
  - 目的；实现OS多道程序的并发、共享
  - 唯一标志：进程控制块 PCB Process-Control-Block
    - 进程创建时创建，常驻内存，任一时刻可存取，进程结束时删除
    - 主要包括：进程描述信息（进程标识符，用户标识符），进程控制&管理信息（当前状态、优先级等），资源分配清淡，处理机相关信息 P32
    - PCB组织方式：链接方式（队列），索引方式（索引表）
  - 特征：动态性（最基本），并发性，独立性，异步性，结构性
  - 进程结构 = 进程实体 = 进程映像 =  PCB + 程序段 + 相关数据段，静态
- 进程状态切换
  - 五状态模型：创建，就绪（基本），运行（基本），阻塞（基本），终止
    - 转换：创建 →就绪 →运行 [→阻塞/等待 →就绪 →运行] →结束
    - 就绪：仅缺少处理机，被动等唤醒原语Wakeup变就绪
    - 阻塞：除处理机外需等待其他资源or某一事件，主动调阻塞原语Block变阻塞
  - 七状态模型：五状态添加 就绪挂起，阻塞挂起
- 进程间通信
  - 低级：PV操作
  - 高级：共享存储（共享空间），消息传递-格式化消息为单位-直接通信（缓冲队列）/间接通信（电子邮件），管道通信（管道 = 共享文件），IPC
- 线程：系统独立调度的基本单位，基本的CPU执行单元
  - 目的：减小程序并发执行时的时空开销
  - 组成：线程ID，程序计数器，寄存器集合，堆栈
  - 实现：用户级线程-应用程序完成所有线程管理-内核不知，内核级线程-内核完成所用线程管理-应用程序只有接口，混合型
  - 多线程模型
    - 一对一：一个用户级线程映射一个内核级线程
    - 多对一：多个用户级线程映射到一个内核级线程，线程管理在用户空间完成
    - 多对多：n个用户级线程映射m个内核级线程，m≤n
- 作业：用户要求计算机完成的一串任务
## 处理机调度（CPU调度）
- 调度：决策行为，决定资源分配给哪个进程
- 切换：执行行为，实际进行分配操作
- 作业从提交到完成的调度层次：三级调度 P51
  - 作业调度（高级调度）：创建进程、获得竞争处理机的权利，分配内存、设备等必要资源，内存-辅存层，每个作业只调入一次，调出一次，频率最低
  - 中级调度/内存调度：提高内存利用率、系统吞吐量，进程挂起/调到外存等待、唤醒调入内存就绪，频率次低
  - 低级调度/进程调度：按某种方法策略从就绪队列选出进程、为之分配处理机，最基本，频率最高
- 进程调度方式
  - 非剥夺/非抢占式调度：让当前进程执行完成，适用批处理系统，如先来先服务，短作业优先？
  - 剥夺/抢占式调度：立即暂停当前执行的进程，适用分时、实时系统，如最短剩余时间，短进程优先，优先级调度，轮转调度？
- 调度算法性能比较准则：最大化CPU使用率、吞吐量，最小化三个时间
  - CPU利用率：尽可能高
  - 系统吞吐量：单位时间内CPU完成作业的数量
  - 周转时间 = 作业完成时间 - 作业提交时间
    - 平均周转时间 = n个作业的周转时间和 / n
    - 带权周转时间 = 作业周转时间 / 作业实际运行时间
    - 平均带权周转时间 = n个作业的带权周转时间和 / n
  - 等待时间：进程处于等待处理机的状态（就绪态）的时间总和，与处理机调度算法有关
  - 响应时间：用户提交请求 到 系统首次产生相应的时间
  - 平均等待时间 = (总周转时间 - 总执行时间) / 完成的进程数
- CPU周期：
### 典型调度算法
- 分情况适用于作业调度、进程调度、或二者都适用
- 先来先服务 FCFS，二者适用，First-Come-First-Serve
  - 不可剥夺，公平，适用短进程，IO进程不友好
  - FIFO队列实现，性能受进程时间+到来顺序影响大
  - 问题：护航效应，允许大进程长期占用CPU时间，其他进程都在等
- 短作业/短进程优先 SJF SPF，二者适用，Shortest-Job/Progress-First
  - 优先CPU周期（执行时间）最短的，最短/最优平均等待时间、平均周转时间
  - 问题：长进程饥饿，无法准确获取CPU周期，使用指数平均方法预测
- 优先级调度算法，二者适用 Priority scheduling
  - 分类：非剥夺式，剥夺式
  - 优先级分类：静态-创建进程时确定优先级且保持不变，动态-进程运行过程中动态调整优先级
  - 问题：低优先级无穷阻塞/饥饿
  - 解决：老化思想，逐渐增加等待时间长的进程的优先级
- 最高相应比优先调度算法，作业调度
  - 响应比 Rp = (等待时间 + 要求服务时间) / 要求服务时间
  - 改进的FCFS、SJF，不会饥饿，计算开销大
- 时间片轮转调度算法 RR，分时系统，Round-Robin scheduling
  - 一个就绪队列，执行队首进程，在Δt内没完就超时中断，放到就绪队列队尾
  - 时间片Δt通常大小 = 10~100ms，时间片的选取和轮转效率挂钩
  - 实时性好，利于交互，进程切换开销大
- 多级反馈队列调度算法 Multilevel-Feedback-Queue
  - 实现过程
    - 多个就绪队列，赋予不同的队列不同的优先级、时间片，第一级优先级最高，各就绪队列可有不同的队列内调度算法
    - 优先级越高↑的队列中，每个进程运行的时间片越小↓
    - 新进程先进入第一级队列末尾排队，轮到它时在第一个时间片内没完成，便调入第二级队列末尾排队，以此类推
    - 仅当第一级队列空时，才运行第二级队列的进程；被抢占则先放入当前级队列末尾排队
  - 改进的时间片轮转、优先级调度，综合性强，不同长度时间片队列
  - 问题：可能饥饿
- 多级队列调度 Multilevel-Queue
- 最短剩余时间算法 SRTF，Shortest-Remain-Time-First scheduling
  - 允许抢占的SJF
  - 就绪队列进程的剩余执行时间＜正在执行的进程的剩余执行时间，就抢占
- 睡眠排序是根据哪个cpu调度算法？？
## 进程同步、互斥
- 目的：控制多道OS进程的异步性、临界资源的互斥访问
  - 临界资源：一次仅允许一个进程使用的资源，必须互斥访问
  - 临界区 = 访问临界资源的代码
  - 临界区原则：空闲让进，忙则等待，有限等待，让权等待
    - 实现临界区互斥，需满足前三个条件，不一定要求让权等待
    - 让权等待：当进程不能进入自己的临界区时，应立即释放处理机
    - ？？进程长时间不能进入临界区才需要放弃处理机，而不是立即放弃
  - 同步：直接制约，协作关系，进程间相互合作完成一个任务，需要在某些位置上协调进程之间的工作次序，在关键点上等待另一个进程发来的消息
  - 互斥：间接制约，竞争关系，一个进程进入临界区使用临界资源时，其他进程必须等待，只能逐一使用临界资源
- 互斥的软件实现：单标志法，双标志法先检查，双标志法后检查，Peterson算法（flag解决临界区的互斥访问，turn解决饥饿现象）
- 互斥的硬件实现：中断屏蔽，硬件指令-硬件逻辑直接实现 TestAndSet指令（读并设标志为真）+ Swap指令（交换）
- 信号量机制-解决互斥和同步问题
  - PV操作，PV原语，原子操作，不可中断
    - S = 信号量（值允许＞1，初值需看情况设置），就是flag、标志的作用
      - 整型信号量：整型S表示资源数目，wait中会不断测试从而“忙等”
      - 记录型信号量：记录型数据结构semaphore S = {资源数目value，进程链表L}，L链接所有等待该资源的进程P们
    - P(S) = wait(S) 阻塞原语，申请一个资源，S = S-1，资源已占则block(P)，Proberen（测试，荷兰语）
    - V(S) = signal(S) 唤醒原语，释放一个资源，S = S+1，有进程等则wakeup(P)，Verhogen（增加，荷兰语）
  - 进程同步实现：在两个进程中分别P和V，如需要进程P1中语句X执行后进程P2才能执行，则设置信号量S=0，P1中语句X后V(S)表示P1已完成一次X、S增加1，进程P2中先P(S)申请一个资源来查询X是否完成、S减少1，若在P(S)时S＜0则P2阻塞等待，并循环检查S的当前值直到可以申请到
  - 进程互斥实现：在一个进程中访问临界区前后进行PV，P(S)申请资源 →访问 →V(S)释放资源
  - 实现进程前趋关系：前趋关系图，使用进程同步
- 管程
  - 一组数据和定义在数据上的对数据的操作组成的软件模块
  - 组成：局部与管程的共享结构数据说明，对改数据结构进行操作的一组过程，对局部于管程的共享数据设初值的语句
  - linux中HORE管理-A等B执行，MESA管理-B等A执行
- PV操作问题们
  - 信号量值的隐含信息：S＞0 可用资源个数为S，S=0 该资源用完，S＜0 等待使用资源的进程个数刚好为S
  - 互斥访问变量 Semaphore S，P总数 = V总数
  - 生产者消费者问题
    - 生产者、消费者共享一个初始为空、大小为n的缓冲区，同一时刻只能有一方操作缓冲区，不满可生产，不空可取
    - 有数据缓冲区信号量 full = 0，空缓冲区信号量 empty = n，临界区互斥信号量 mutex = 1
    - 对缓冲区的操作互斥，full和empty联动表示缓冲区状况
  - 读写者问题
    - 读者、写者共享一个文件，可同时读，只可有一个写，读写不能同时
    - 当前读者数量 count = 0，读写互斥 rw = 1，控制互斥修改count mutex = 1，写优先信号量 w = 1
    - 读者不互斥-添加循环
  - 哲学家就餐问题
    - 圆桌上一圈哲学家，两两之间有一根筷子，一根一根地拿到两根筷子可以进餐
    - 筷子资源互斥信号量数组 chopstick[5] = {1,1,1,1,1}，互斥取筷子动作的信号量 mutex = 1
    - 同时考虑能拿起两支筷子，防止死锁（思想与贪心算法相反）
  - 吸烟者问题
    - 一个供应者无限随机提供三种材料中的两种，三个抽烟者分别持有一种材料，抽烟者集齐三种材料可抽烟
    - 烟草和纸的信号量 offer1 = 0，烟草和胶水的 offer2 = 0，纸和浇水的 offer3 = 0，抽烟是否完成 finish = 0
- 自旋锁
## 程序出错
- 死锁：多个进程因竞争不可剥夺资源造成的互相等待/阻塞的僵局，若无外力作用则无法向前推进
  - 充要条件：互斥，不可剥夺，请求保持，循环等待
- 死锁处理策略：预防，避免，检测和解除
- 死锁预防：死锁发生前，破坏死锁产生的条件之一or之几
  - 破坏互斥：不太可行
  - 破坏不剥夺：常用于状态易保存和恢复的资源，如CPU寄存器、内存，一般不能用于打印机之类的
  - 破坏请求和保持；预先静态分配方法，进程运行前一次申请完所有资源，都满足才能运行，直到运行结束释放资源
  - 破坏循环等待：顺序资源分配法，进程按编号递增的顺序申请资源，同类资源一次申请完
- 死锁避免：死锁发生前，在资源的动态分配过程中，防止系统进入不安全状态
  - 安全状态：可避免死锁，系统能按某种进程执行并释放资源的顺序序列，动态地按序为每个进程Pi分配所需最大资源，使之都能顺利完成
  - 不安全状态：死锁必为不安全状态，不安全状态必定？可能？但非立刻进入死锁
  - 银行家算法：
    - 数据结构描述
      - 可用资源矩阵 Available[m] = K，    则 m = 资源类，K = 第m类资源的可用数目
      - 最大需求矩阵 Max[n][m] = K，       则 n = 进程数，K = 第n个进程申请第m类资源的最大需求
      - 分配矩阵     Allocation[n][m] = K，则 n = 进程数，K = 第n个进程已分配的第m类资源数
      - 需求矩阵     Need[n][m] = K，      则 n = 进程数，K = 第n个进程还需要的第m类资源数
      - Need = Max - Allocation，还差多少 = 最大需求 - 已分配的
      - 进程Pi请求   Request[j] = K，      则第i个进程为Pi，K = 请求的第j类资源数
    - 算法描述
      - 当进程Pi请求第j类资源K个，按以下顺序进行检查，成功则往下，否则Pi需等待
      - 1、请求j类K个＜需求j类k个
      - 2、请求＜可用
      - 3、假设已经分配K个给进程Pi，计算出已分配后各个矩阵/资源的变化情况
      - 4、在此情况下执行系统的安全性算法，检查系统是否为安全状态
    - 安全性算法（安全状态）
      - 思想：找到一个能把进程都一个个顺着执行完的资源分配顺序，则 进程执行顺序序列 = 安全序列
      - 1、进程Pi当前时刻Need＜可用Available，将Pi所Need的全分配给Pi
      - 2、Pi可以执行完，后释放资源，更新各个矩阵，再找下一个满足条件的Pi
      - 3、若能顺利执行完所有进程，则安全
  - MOOC中三角平面图：
- 死锁检测、解除：不进行限制，允许发生死锁，通过检测机构检测，采取措施解决死锁
  - 资源分配图
    - 一个圆圈 = 一个进程，一个方框 = 一类资源，方框中的一个圆点 = 该类资源中的一个资源
    - 请求边 = 进程到资源的有向边 = 进程正在请求一个该资源
    - 分配边 = 资源到进程的有向边 = 该资源已经有一个分配给进程
    - 图形资源固定，以边表示当前的分配状态
  - 死锁检测：死锁发生时
    - 死锁定理：S为死锁 <=> S状态的资源分配图是不可完全简化的，完全简化 = 能消去资源分配图中所有的边
    - 用进程资源分配图检测死锁状态，思路类似系统安全状态检查
    - 找能被满足请求的资源的进程，满足后释放，去掉该进程的请求边和分配边，再找下一个进程
  - 死锁解除：资源剥夺，撤销进程，进程回退
- 活锁：进程正常调度，不阻塞，但是无进展，如：无意义地while死循环
- 饥饿：由分配调度策略导致，某个进程一直阻塞，进程在信号量内无穷等待


# 三、内存管理（结合计组の存储系统）
- 内存管理：操作系统对内存的划分、动态分配（主存中不可能放下全部用户进程和系统程序数据）
- 功能：内存空间的分配和回收，地址转换，内存空间扩充，存储保护
- 程序执行过程：编译 →链接 →装入
  - 编译：由用户源代码产生若干目标模块 + 其自身的逻辑地址
  - 链接：形成整体逻辑地址/装入模块
    - 静态链接一次性装入，装入时边装边动态链接，运行时需要才动态链接
  - 装入：将装入模块装入内存运行
    - 绝对装入：连续，物理地址 = 逻辑地址，适于单道程序环境
    - 可重定位装入：连续，静态重定位，一次性全装入
    - 动态运行时装入：可离散，动态重定位，进程使用时现装入，使用重定位寄存器
- 内存保护
  - 越界保护：越界中断，上下限寄存器存放着地址上下限
  - 基址/重定位寄存器、限长/界地址寄存器：基址为最小物理地址，限长为最大逻辑地址，比限长寄存器小后，再与基址寄存器相加得物理地址
- 内存扩充（多道程序环境）
  - 覆盖：用户空间分成一个固定区、若干覆盖区，在同一进程or同一程序中进行，基本不用
  - 交换
    - 内各种调度算法相关，在不同进程or不同作业之间进行，广泛使用
    - 换出；把等待状态的程序 从内存移到辅存
    - 换入：把就绪状态的程序 从辅存移到内存
    - 注意：需要备份存储，转移时间，空闲换出
- 工作集 = 驻留集：某段时间间隔内，进程要访问的页面集合
- 地址重定位，地址翻译，高位低位，表示的进制？？
- 访存时间，考虑块表 + 缺页中断
## 内存分配
- 内部碎片：固定分区时，分区内部产生的碎片，程序＜空间大小，分区内部存在空间浪费
- 外部碎片：动态分区时，在进程换入换出过程中，产生小内存快
### 连续分配：分配给用户进程or作业的必须是一个连续的内存空间
- 单一连续分配
  - 分为系统区、用户区
  - 优点：无外部碎片，可用覆盖技术
  - 缺点：有内部碎片，只适于单用户单任务，主存利用率低
- 固定分区分配
  - 用户内存划分为若干固定大小分区，每个分区只装一道作业，空闲可装
  - 若分区大小相等：适于多个相同对象，但不灵活
  - 若分区大小不等：可能程序太大无法放入任何分区，主存利用率低
  - 优点：无外部碎片，适于多道程序，最简单
  - 缺点：有内部碎片，主存利用率低
- 动态/可变分区分配
  - 进程装入内存时，根据进程大小、动态地在空闲块中建立分区，使之正好适合进程
  - 常用数据结构：空闲分区表，空闲分区链表
  - 分配算法（首次-地址↑、最佳-容量↑、最坏-容量↓）
    - 最简单最好最快：首次适应＞最佳适应＞最坏适应
    - 首次适应 First-Fit：空闲分区按 地址递增链接，顺序查找，选择满足要求的第一个空闲分区
    - 最佳适应 Best-Fit：空闲分区按 容量递增链接，顺序查找，选择满足要求的第一个空闲分区
    - 最坏适应 Worst-Fit = 最大适应 Largest-Fit：空闲分区按 容量递减链接，顺序查找，选择满足要求的第一个空闲分区
    - 邻近适应 Next-Fit = 首次循环适应：在首次适应算法中，从上次查找结束的位置开始顺序查找
  - 外部碎片处理：紧凑技术，即 时常对进程进行移动、整理
- 伙伴分配：对半分 + 合并，最合适大小 (2^n)-1 ＜ x ＜ 2^n
### 非连续分配：允许给用户进程分配一些分散的内存空间，即一个进程分散地装入不相邻的内存分区
- 基本分页 存储管理：分区大小固定（基本分页-全装入运行，请求分页-可分次装入）
- 基本分段 存储管理：分区大小可变
- 分页 存储管理
  - 主存空间划分为大小相等、固定的分区/块，以此分区大小为基本单位
  - 进程空间也划分为和主存块大小相等的块，并以块为单位逐个申请主存的块空间
  - 进程未执行时，页表的起始地址、页表长度 放在进程控制块PCB中
  - 地址空间：一维的
  - 优点：无外部碎片
  - 缺点：平均每个进程在最后一个页面处，可能产生半个块大小的内部碎片（页内碎片），页框过大则可能在产生过大的内部碎片
  - 基本单位：分区，即 把某空间划分成的大小相等的分区（类似划分Cache块），此大小即为页面大小，一般为2的整数幂
    - 主存 划分叫：页框，页帧，块，内存块，物理块
    - 进程 划分叫：页，页面（进程划分的页面大小需要和内存页框大小一致）
  - 每个分区有自己的编号，编号都从 0 开始，即 页号 = 3 表示 这是第 4 页，操作系统用编号来进行分页存储管理
    - 页框 编号叫：页框号，页帧号，块号，内存块号，物理块号，实页号？
    - 页面 编号叫：页号，页面号，虚页号？
  - 分页：OS以页框为单位，为各个进程分配内存空间，进程的每个页面分别放入不同页框，一一对应，不要求顺序
    - 地址转换：将进程使用的逻辑地址，对应到主存的物理地址，即找到程序真正所在的物理地址
    - 页号 = 逻辑地址 / 页面长度，即 算出该逻辑地址 处于 整个进程的第几页
    - 页内偏移量 = 逻辑地址 % 页面长度，即 算出该逻辑地址 在该页内的 相对地址
  - 逻辑地址划分结构 = { 页号P | 页内偏移量W }
    - 如 将存储器按字节编址，主存地址为32位，主存容量即物理内存4GB=2^32B，页面大小为4KB=2^12B
      - 页内偏移量（即页内地址）占12位，剩32-12=20位，即为页号占位
      - 页内偏移占12位 = 可表示页内地址2^12个 = 每页大小为2^12为4KB
    - 页号占20位 = 一个进程最多允许有2^20页
  - 物理地址划分结构E = { 块号b | 页内偏移量W }
    - 十进制下计算，给出十进制的页面大小L、逻辑地址A、页表长度M、页表起始地址 F，计算物理地址E
    - 页号 P = A / L，页内偏移 W = A % L，若 P≥M，则越界中断
    - P 的页表项地址 = F + P * 页表项长度，取出内容b为物理块号
    - 实地址 = 页框号 * 页面大小 + 页内偏移
    - 如：页面大小L=1K字节，页号2对应物理块b=8，逻辑地址A=2500，计算页号P=2500/1K=2，W=2500%1K=452，物理E=8*1K+452=8*1024+452=8644

    - 理解？？先有逻辑地址，如每个进程都从0开始编址，某逻辑地址为A，为解决为程序分配内存空间的问题而引入分页，∵二进制的进位特性（王道2019视频部分），使得可以按二进制进位逻辑划分一下A，分为页号、页内偏移地址两部分，再找个物理块（物理块有自己的块号）来分配给该页，用页表记录页号、块号的对应关系

  - 页表：记录进程页面 与 进程页面在内存中实际存放位置 的对应关系，一个进程有一张页表，页表存放在内存中
    - 页表项 = { 页号P | 页框号b }，一个页表项 记录 进程一页与主存一页的对应关系
    - 页表项长度 = 一个页表项占用的存储空间大小
      - 同一页表内每个页表项的长度相同，且页表项们 按顺序、连续地存储在内存中，此时，页号是“隐含”的
      - “隐含”即 找物理块号时，可以不去显式地写出每个页表项的页号是多少、这样顺序地算，可用以下方法
    - 页表长度 = 该进程的总页数，即该进程一共有多少页
    - 页表寄存器 = { 页表起始地址F | 页表长度（即页数）M }
    - 页表项地址 = 页表起始地址 + 该页表项存的页号×页表项长度
  - 页表项的大小问题
    - 以 32 位逻辑地址空间，字节为编址单位， 一页 4KB 为例
    - 地址空间内一共含有 2^32B/4KB=1M 页，则需要20位才能保证其表示范围能容纳所有页面
    - 又因为以宇节B作为编址单位，即页表项的大小二三 f20!8l=3B
    - 所以在这个条件下，为了保证页表项能够指向所有页面，那么页表项的大小应该大于弛
    - 当然，也可以选择更大的页表项 大小以至于让一个页面能够正好容下整数个页表项以方便存储（例如取成 4B，那么一页正好可以 装下 IK 个页表项），或者增加以前其他信息。

      - 理解？？？页表、页表项、页表项长度其实是按需构造的、从逻辑上来说？？
      - 如 若按字节编址，如内存4GB，则内存块数 = 4GB/4KB = 2^20个，物理块号需要20位来存，即至少3字节（因为按字节编址），而进程页号至少1位、至多暂时没定，so若将页表项长度定为3B，又∵人为规定页表项长度一定、顺序连续存储，∴要找第n页号的物理地址，可以直接用 页表起始地址 + n×页表项长度 定位到页表项地址
      - 而当页表项长度定位3B后，共24位，其中后20为是物理块号，剩下前4位就作为逻辑页号，也就只允许一个进程最多有2^4=16页
      - 更极端一点的，若物理块号刚好需要24位、即整3字节来存，那么页号至少1位，拼接上块号凑成页表项至少1+3B位，按字节编址，则页表项至少要4B来存，即32位地址空间

  - 快表TLB/联想寄存器
    - 为页表而设的Cache，在高速缓冲存储器中、存放高频使用的若干页表项，基于局部性原理
      - 页表存储在内存中，取指or取数据CPU至少要访存两次（找页表项一次、找物理块一次），时间是平时的两倍
      - 其他和其他Cache性质大同小异，如先访Cache，命中or不命中，快表满时的替换算法等
    - 对应的页表即为慢表
  - 二级页表（多级页表）
    - 一张完整页表需连续存放，当其占用的存储空间很大时，需要占用多个连续的页框（物理块）
    - 为了让过大页表能够分散存储，不用让整个大页表都常驻内存，可以只有用到的特定页面
    - 多级页表
      - 将一张页表进行分组，分组大小要求一个分组能刚好放入一个内存块，每个分组就成为一个新的小页表
      - 然后，为这些新的小页表们建立一张上级页表，即页目录表（或外层页表、顶层页表），用于存储小页表的顺序关系、小页表物理地址的存放位置
    - 页目录表项 = { 页目录号（一级页号） | 对应页表存放的页框号 }，其中，规定一个二级页表占用空间为一个物理块
    - 二级页表项 = { 二级页号 | 对应页存放的页框号 }
    - 多级页表中，各级页表占用的空间大小不可超过一个页面
    - 具有二级页表的程序逻辑地址的划分结构 = { 一级页号 | 二级页号 | 页内偏移 }
      - ？？寻址：程序先从逻辑地址中

    - 二级页表的访存次数：（设没有快表TLB）
      - 第一次：访问内存中的页目录表
      - 第二次：访问内存中的二级页表
      - 第三次：访问目标的内存单元
      - n级页表，需访存 n+1 次

    - 理解？？？对于虚拟地址（逻辑地址）来说，先有这个地址，然后按需分区，分为页号、页内地址，然后再按需将页号段再分为一级和二级？？

- 分段存储管理
  - 离散分配时，分配的地址空间的基本单位：段
  - 按程序的逻辑分段，段内地址连续，段间不要求连续，有外碎片
  - 地址空间：二维的
  - 分段基本概念
    - 逻辑地址 = { 段号S | 段内偏移量W }，定要显式给出才能求得物理地址
    - 段表 = 记录段在内存中的起始地址和长度
    - 段表项 = { 段号S | 段长C | 段在主存的起始地址b }
    - 段表寄存器 = { 段表始址F | 段表长M }，S≥M则越界中断
    - 段号S的段表项地址 = 始址F + 段号S * 段表项长度
    - 物理地址 = 起始地址b + W
- 段页式存储
  - 段表页表结合，一个进程建立一张段表，一个分段有一张页表，一占个进程只有一个段表，可有多个页表
  - 地址空间：二维的
  - 逻辑地址 = { 段号S | 页号P | 页内偏移量W }
  - 段表项 = { 段号 | 页表长度 | 页表始址 |...}
  - 页表项 = { 页号 | 物理块号 |...}
  - 段表寄存器 = { 段表始址F | 段表长M }
- 段表、页表寄存器作用：寻址，判断越界
## 虚拟内存管理
- 传统内存管理：作业一次性装入，运行过程驻留性
- 局部性原理（高速缓存技术的依赖原理）
  - 时间局部性：执行过的指令不久后可能再次执行，访问过的数据不久后可能再次访问
  - 空间局部性：在访问过的存储单元附近的存储单元也可能被访问，即程序在一段时间内访问的地址可能集中在一定范围
- 虚拟内存：内存-外存层，基于局部性原理，在逻辑上扩充内存，对用户完全透明，小取决于系统位数
- 虚拟存储器特性：多次性装入，对换性不常驻，虚拟性逻辑扩充
- 硬件支持：一定容量内存、外存，页表/段表机制，中断机构，地址变换机构
  - 页表机构
    - 页表项 = { 页号 | 物理块号 | 状态位 | 访问字段 | 修改位 | 外存地址 }
    - 状态位：标识该页是否已调入内存
    - 访问字段：记录该页一段时间内被访问的次数，or该页最近多久未被访问
    - 修改位：标识该页在调入内存后是否被修改过
    - 外存地址：该页在外存上的地址，一般是物理块号，调页时用（页号和第二位的物理块好为寻址时用）
  - 缺页中断机构：属于系统异常
    - 与一般中断区别的特性：指令执行期间产生-属于内部中断，一条指令可能产生多次缺页中断
- 实现方式：请求分页存储管理，请求分段存储管理，请求段页式存储管理
- 页面置换算法：选择调出的页面
  - 最佳置换 OPT Optimal-Replacement-Algorithm
    - 调出以后永不使用的页面，or最长时间内不再被访问的页面
    - 存在于理论，无法实现，多用于评价比较其他算法优劣
  - 先进先出 FIFO
    - 调出最早进入内存的页面，即在内存中驻留时间最久的，基于队列实现
    - Belady异常：分配的物理块数增加↑，缺页故障数反而增加↑（只有FIFO会出现）
  - 最近最久未使用/最近最少使用 LRU Least-Recently-Used
    - 调出最近最长时间未访问过的页面，基于堆栈实现
    - 性能接近OPT，但实现成本高，需要寄存器、栈的硬件支持
  - 时钟 Clock = 最近未使用 NRU Not-Recently-Used
    - 每页设置一个使用位u，首次调入内存时 u = 1，页被访问时 u = 1
    - 调页步骤
      - 从当前位置开始，指针循环扫描缓冲区
      - 若 u = 0 则调出第一个遇到的该页，若 u = 1 则将u置为0
      - 若 u全为1 则完整循环一周全置0再找
      - 若 u全为0 则替换遇到的第一个该页
    - 性能接近LRU
  - 改进的Clock
    - 考虑页面修改，每页设置一个使用位 u 、修改位 m ，替换时首选最近没用且没变化的页
    - 调页步骤
      - 从当前位置开始，指针扫描缓冲区，找第一个 u = m = 0 的页调出
      - 若没找到，则重新扫描，若 u = 0，m = 1 则调出第一个遇到的该页，若 u = 1 则将u置为0
      - 若没找到，则重新扫描，找第一个 u = m = 0 的页调出
- 页面分配策略
  - 驻留集/工作集：在一定时间内进程要访问的页面集合，最好相近于分给进程的主存空间、进程在主存中驻留的页数
  - 驻留集大小分配策略
    - 固定分配-局部置换
      - 为进程分配一定物理块，该进程块数在运行期间保持不变
      - 缺页：在分配给该进程的块中换入换出页
    - 可变分配-全局置换
      - 最简单，每个进程分配一定量物理块，OS自身保持一个空闲块队列
      - 缺页：调入的页放入一个空闲块，将该空闲块分配给进程
    - 可变分配-局部置换
      - 每个进程分配一定量物理块
      - 缺页：在分配给该进程的块中换入换出页
      - 频繁缺页：OS再为进程分配若干物理块，直到缺页率适当
      - 缺页率低：OS减少为进程分配的物理块，直到缺页率适当
- 调入页面策略
  - 预调页策略：预测，多用于首次调用，由程序猿给出
  - 请求调页策略：进程缺页后请求
  - 调页的外存：存放文件的文件区，存放对换页面的对换区
- 颠簸 = 抖动
  - 刚换出的页面马上又换入，刚换入的页面马上又换出
  - 主要原因：进程频繁访问的页面数＞可用物理页数
- 地址翻译（结合计组-Cache）P184
- 地址翻译：快表TLB →页表 →Cache →主存 →辅存

# 四、文件管理
- 文件控制块 FCB，File Control Block？？
- 文件目录系统
## 用户角度
- 用户进行输入输出，以文件为基本单位
- 文件组成：一块存储空间 + 其中的数据，分类 + 索引信息，访问权限信息
- 文件结构：数据项-最低级的数据组织形式，记录-相关数据项集合
- 逻辑结构：无结构-流文件，有结构 =｛顺序结构文件，索引文件，索引顺序文件，散列文件｝
- 文件操作-系统调用
  - 创建Create：申请目录项创建FCB，申请磁盘块
  - 打开Open：返回文件描述符，文件信息填入打开文件表
  - 指针定位Seek：为后续读写操作服务
  - 读Read，写Write，文件重定位，删除，复杂组合操作
- 文件分类：普通文件，特殊文件，目录文件，管道文件，套接字等
- 文件目录
  - 实现：线性链表，哈希表
  - 结构组成
    - 文件目录项：一个文件有一个目录项，文件控制块FCB，索引节点 + i节点
    - 文件目录：属于目录文件，目录项对应的集合
  - 执行方式
    - 找到 指定目录FCB →下级目录FCB →指定文件FCB
    - 找到 索引节点 →对应i节点 →...
  - 目录类型：与访盘次数结合考虑
    - 单级目录-无法实现多用户&文件不可重名，多级目录，树形目录-使用最普遍，环形目录-实现文件共享
- 文件访问：相对路径，绝对路径
- 文件共享：与共享文件的增删结合考虑
  - 软链接-基于符号链-Link文件，硬链接-基于索引节点
- 文件保护：口令保护，密码保护，访问控制-rwx指令类型
- 文件系统备份：增量备份-备份快恢复慢，全量备份-备份慢恢复快
## 操作系统角度
- 层次结构：用户调用接口 →文件目录系统 →存取控制验证 →逻辑文件系统+文件信息缓冲区 →物理文件系统 →分配模块 →设备管理程序模块
- 文件分配
  - 连续分配：随机访问，文件长度一般固定
  - 链接分配：指针依次访问，文件长度可变，分为：隐式链接，显式链接-FAT表
  - 索引分配：随机访问，文件长度可变，分为：直接索引，单级索引，多级索引，多级混合索引-UNIX中三级索引结构+分析文件大小计算
  - 区分：动态分区分配-是内存管理方式，而以上三种是磁盘空间管理方式
- 文件存储空间管理
  - 空间划分：内存 + 磁盘
  - 磁盘部分
    - 磁盘分区-物理，文件卷-逻辑，格式化，目录文件，用户文件
    - 引导区：UFS引导块，NTFS分区引导扇区，位于启动磁盘or系统盘中，用于引导系统
    - 卷，分区信息：UFS超级块，NTFS主控文件表，用于所在文件卷的管理
  - 内存部分：所有安装分区的信息，系统打开文件表，单个进程打开文件表
  - 管理方式：空闲表法，空闲链表法，位视图？位示图？法，成组链接法
- 物理存储
  - 磁盘读写结构：磁头-磁道，柱面，扇区
  - 磁盘读写操作：寻道时间，延迟时间，传输时间
  - 磁盘调度算法
- 磁盘调度算法
  - 先来先服务 FCFS
  - 最短寻找时间优先 SSTF
  - SCAN
  - C-SCAN
  - 旋转调度算法：考虑处理时延，同磁头不同扇区，不同磁头相同编号扇区，不同磁头不同编号扇区
- 个人OS的文件系统
  - Windows：FAT32，支持Unicode-两字节表示一个字符，支持长文件名格式，多个目录项
  - UNIX：UNIX V，UNIX三级混合文件索引，FCB拆分为索引目录项 + i节点

# 五、输入/输出管理(I/O)
- IO设备分类
  - 按使用特性：人机交互类，存储设备，网络通信设备
  - 按传输速率：低速，中速，高速
  - 按信息交换的单位：块设备，字符设备
- IO控制方式
  - 程序直接控制：CUP始终占用
  - 中断驱动方式：每传输完成一个字符，CPU占用一次
  - DMA方式：开始时、结束时 CPU占用
  - 通道控制方式：自主权更高
- IO系统层次结构
  - 用户层IO软件：服务于用户
  - 设备独立性软件：设备无关性，映射逻辑设备与物理设备
  - 设备驱动程序：为IO系统隐藏设备控制器之间的差异
  - 中断处理程序：进程上下文切换
  - 硬件设备：电子部分-设备控制器即适配器，机械部分
- IO编址：IO独立编址，占用内存编址
- IO进程：专门处理OS中的IO中断与IO请求
- 设备分配
  - 相关数据结构
    - 设备控制表DCT，控制器控制表COCT，通道控制表CHCT，系统设备表SDT
    - DCT COCT 一一对应，CHCT 一对多个 COCT，一个系统中只有一个SDT
  - 主要考虑因素：设备固有属性，分配算法，分配安全性，独立性
  - 策略：静态分配-用于独占设备，动态分配-可能死锁，相关算法-先请求先分配、优先级分配
  - 安全性：安全分配方式-CPU、IO串行工作-效率低，不安全分配-可能死锁
- Spooling技术：空间换时间
  - 意义：提高IO总体速度，将独占设备改为共享，实现虚拟设备，缓和CPU高速与IO低速的矛盾
- IO性能相关
  - 缓冲技术-缓冲区：单缓冲区，双缓冲区，循环缓冲区，缓冲池-生产者消费者问题
  - 高速缓存技术：利用局部性原理，关联LRU算法
  - 异步IO
  - 异步传输技术
  - 信息优化分布
  - RAID技术：RAID 0条带化，RAID 1镜像，RAID 4交错块奇偶校验
## 核心子系统
- 高速缓存
- 缓冲区


# 相关其他
## java内存池
- 一般的系统接口申请内存：
  - C/C++ malloc/free
  - java new/delete
- 在内存碎片中寻找最接近申请大小的内存块，返给申请者，容易造成众多小块内存碎片无法利用
- 内存池：
  - 定长分配，每次分配固定长度
  - 变长分配
- 定长分配：每次申请固定长度，使用时利用栈，例如存储一个变量，申请malloc内存，便入栈一个，直到这个长度的内存使用完毕，再一次申请定长内存；free即出栈

